<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"m0nst3r.me","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="[TOC] 数值比较主要程序12345678910111213141516171819202122232425#include&lt;stdio.h&gt;void f_signed(int a,int b)&amp;#123;	if(a&gt;b)		printf(&quot;a&gt;b\n&quot;);	if(a&#x3D;&#x3D;b)		printf(&quot;a&#x3D;&#x3D;b\n&quot;);	if(a&lt;b">
<meta property="og:type" content="article">
<meta property="og:title" content="逆向工程——条件转移指令">
<meta property="og:url" content="https://m0nst3r.me/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.html">
<meta property="og:site_name" content="m0nst3r&#39;s blog">
<meta property="og:description" content="[TOC] 数值比较主要程序12345678910111213141516171819202122232425#include&lt;stdio.h&gt;void f_signed(int a,int b)&amp;#123;	if(a&gt;b)		printf(&quot;a&gt;b\n&quot;);	if(a&#x3D;&#x3D;b)		printf(&quot;a&#x3D;&#x3D;b\n&quot;);	if(a&lt;b">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://m0nst3r.me/images/580ed4d7a27514ace73ff4494450f5940e6cebc3.png">
<meta property="og:image" content="https://m0nst3r.me/images/b34259296524fba6ee3624fcdd6cf7f9d7bd1673.png">
<meta property="og:image" content="https://m0nst3r.me/images/0e25f1f9c88bd3dd66293bae9952cec7a6a5dfc5.png">
<meta property="og:image" content="https://m0nst3r.me/images/e7c2977fad694173c565d5865660ebd8565a737e.png">
<meta property="og:image" content="https://m0nst3r.me/images/48b2cada6dba2552b832c767976c8d651d7da4ea.png">
<meta property="og:image" content="https://m0nst3r.me/images/c6eef2fc870cd95ed7191320b0c8f2761c4580cf.png">
<meta property="article:published_time" content="2017-12-21T03:12:00.000Z">
<meta property="article:modified_time" content="2022-08-08T14:27:53.027Z">
<meta property="article:author" content="m0nst3r">
<meta property="article:tag" content="Web安全,渗透测试,网络安全,代码审计,逆向,编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://m0nst3r.me/images/580ed4d7a27514ace73ff4494450f5940e6cebc3.png">


<link rel="canonical" href="https://m0nst3r.me/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://m0nst3r.me/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.html","path":"re/逆向工程——条件转移指令.html","title":"逆向工程——条件转移指令"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>逆向工程——条件转移指令 | m0nst3r's blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">m0nst3r's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello, Bugs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83"><span class="nav-number">1.</span> <span class="nav-text">数值比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">主要程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86"><span class="nav-number">1.2.</span> <span class="nav-text">x86</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-msvc"><span class="nav-number">1.2.1.</span> <span class="nav-text">x86+msvc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-MSVC-OllDbg"><span class="nav-number">1.2.2.</span> <span class="nav-text">x86+MSVC+OllDbg</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCC"><span class="nav-number">1.3.</span> <span class="nav-text">GCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Non-optimizing-GCC"><span class="nav-number">1.3.1.</span> <span class="nav-text">Non-optimizing GCC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Optimizing-GCC"><span class="nav-number">1.3.2.</span> <span class="nav-text">Optimizing GCC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARM"><span class="nav-number">1.4.</span> <span class="nav-text">ARM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Optimizing-Keil-6-x2F-2013-ARM-mode"><span class="nav-number">1.4.1.</span> <span class="nav-text">Optimizing Keil 6&#x2F;2013 (ARM mode)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="nav-number">2.</span> <span class="nav-text">计算绝对值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-MSVC"><span class="nav-number">2.2.</span> <span class="nav-text">Optimizing MSVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-Keil-6-x2F-2013-Thumb-mode"><span class="nav-number">2.3.</span> <span class="nav-text">Optimizing Keil 6&#x2F;2013: Thumb mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optimizing-Keil-6-x2F-2013-ARM-mode-1"><span class="nav-number">2.4.</span> <span class="nav-text">Optimizing Keil 6&#x2F;2013: ARM mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Non-optimizng-GCC-4-9-ARM64"><span class="nav-number">2.5.</span> <span class="nav-text">Non-optimizng GCC 4.9 (ARM64)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS"><span class="nav-number">2.6.</span> <span class="nav-text">MIPS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.</span> <span class="nav-text">条件运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">3.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-1"><span class="nav-number">3.2.</span> <span class="nav-text">x86</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARM-1"><span class="nav-number">3.3.</span> <span class="nav-text">ARM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARM64"><span class="nav-number">3.4.</span> <span class="nav-text">ARM64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS-1"><span class="nav-number">3.5.</span> <span class="nav-text">MIPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-if-x2F-else-%E6%9B%BF%E4%BB%A3%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.6.</span> <span class="nav-text">使用 if&#x2F;else 替代条件运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">4.</span> <span class="nav-text">比较最大值和最小值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D"><span class="nav-number">4.1.</span> <span class="nav-text">32位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F-2"><span class="nav-number">4.1.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Non-optimizing-MSVC-2013"><span class="nav-number">4.1.2.</span> <span class="nav-text">指令清单 Non-optimizing MSVC 2013</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Optimizing-Keil-6-x2F-2013-Thumb-mode"><span class="nav-number">4.1.3.</span> <span class="nav-text">指令清单   Optimizing Keil 6&#x2F;2013 (Thumb mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Optimizing-Keil-6-x2F-2013-ARM-mode"><span class="nav-number">4.1.4.</span> <span class="nav-text">指令清单  Optimizing Keil 6&#x2F;2013 (ARM mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Optimizing-MSVC-2013"><span class="nav-number">4.1.5.</span> <span class="nav-text">指令清单  Optimizing MSVC 2013</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E4%BD%8D"><span class="nav-number">4.2.</span> <span class="nav-text">64 位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F-3"><span class="nav-number">4.2.1.</span> <span class="nav-text">程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Non-optimizing-GCC-4-9-1-ARM64"><span class="nav-number">4.2.2.</span> <span class="nav-text">指令清单 Non-optimizing GCC 4.9.1 ARM64</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Optimizing-GCC-4-9-1-x64"><span class="nav-number">4.2.3.</span> <span class="nav-text">指令清单   Optimizing GCC 4.9.1 x64</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%B8%85%E5%8D%95-Optimizing-GCC-4-9-1-ARM64"><span class="nav-number">4.2.4.</span> <span class="nav-text">指令清单  Optimizing GCC 4.9.1 ARM64</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS-2"><span class="nav-number">4.3.</span> <span class="nav-text">MIPS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-2"><span class="nav-number">5.1.</span> <span class="nav-text">x86</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARM-2"><span class="nav-number">5.2.</span> <span class="nav-text">ARM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MIPS-3"><span class="nav-number">5.3.</span> <span class="nav-text">MIPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4-%E9%9D%9E%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.</span> <span class="nav-text">无分支指令(非条件指令)</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">m0nst3r</p>
  <div class="site-description" itemprop="description">Web安全、渗透测试、网络安全、代码审计、逆向、编程</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://m0nst3r.me/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="m0nst3r">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="m0nst3r's blog">
      <meta itemprop="description" content="Web安全、渗透测试、网络安全、代码审计、逆向、编程">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="逆向工程——条件转移指令 | m0nst3r's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          逆向工程——条件转移指令
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-12-21 11:12:00" itemprop="dateCreated datePublished" datetime="2017-12-21T11:12:00+08:00">2017-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-08 22:27:53" itemprop="dateModified" datetime="2022-08-08T22:27:53+08:00">2022-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/category/re/" itemprop="url" rel="index"><span itemprop="name">re</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>[TOC]</p>
<h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><h3 id="主要程序"><a href="#主要程序" class="headerlink" title="主要程序"></a>主要程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void f_signed(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a&gt;b)</span><br><span class="line">		printf(&quot;a&gt;b\n&quot;);</span><br><span class="line">	if(a==b)</span><br><span class="line">		printf(&quot;a==b\n&quot;);</span><br><span class="line">	if(a&lt;b)</span><br><span class="line">		printf(&quot;a&lt;b\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void f_unsigned(unsigned int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a&gt;b)</span><br><span class="line">		printf(&quot;a&gt;b\n&quot;);</span><br><span class="line">	if(a==b)</span><br><span class="line">		printf(&quot;a==b\n&quot;);</span><br><span class="line">	if(a&lt;b)</span><br><span class="line">		printf(&quot;a&lt;b\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	f_signed(1,2);</span><br><span class="line">	f_unsigned(1,2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><h4 id="x86-msvc"><a href="#x86-msvc" class="headerlink" title="x86+msvc"></a>x86+msvc</h4><p>关闭优化选项时，可得到f_signed()函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_a$ = 8</span><br><span class="line">_b$ = 12</span><br><span class="line">_f_signed PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp,esp</span><br><span class="line">	mov eax,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp eax,DWORD PTR _a$[ebp]</span><br><span class="line">	jle SHORT $LN3@f_signed</span><br><span class="line">	push OFFSET $SG737   ;&#x27;a&gt;b&#x27;</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line">$LN3@f_signed:</span><br><span class="line">	mov ecx,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp ecx,DWORD PTR _b$[ebp]</span><br><span class="line">	jne SHORT $LN2@f_signed</span><br><span class="line">	push OFFSET $SG739    ;&#x27;a==b&#x27;</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line">$LN2@f_signed:</span><br><span class="line">	mov edx,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp edx,DWORD PTR _a$[ebp]</span><br><span class="line">	jge SHORT $$LN4@f_signed</span><br><span class="line">	push OFFSET $SG741    ;&#x27;a&lt;b&#x27;</span><br><span class="line">	call _prinf</span><br><span class="line">$LN4@f_signed:</span><br><span class="line">	pop ebp</span><br><span class="line">	ret 0</span><br><span class="line"></span><br><span class="line">_f_signed ENDP</span><br></pre></td></tr></table></figure>
<p>第一个条件转一会领是JLE，即“Junp if Less or Equal”。如果上一条CMP指令的第一个操作数表达式小于或等于（不大于）第二个表达式，JLE将跳转到指令所标明的地址；如果不满足上述条件，则运行下一条指令，就本例而言程序将会调用printf（）函数，第二个条件转移指令是JNE，”Jump if Not Equal“,如果上一条CMP指令的两个操作符不相等，则进行相应跳转。<br>第三个转移指令是JGE，即”Jump if Greater or Equal“，如果CMP的第一个表达式大于或等于第二个表达式（不小于），则进行跳转。这段程序里，如果三个跳转的判断条件都不满足，将不会调用pringtf（）函数；不过除非进行特殊干预，，否则这种情况应该不会发生。<br>现在我们观察 f_unsigned()函数的汇编指令。f_unsigned()函数和 f_signed()函数大体相同。它们的区别集中体现在条件转移指令上:f_unsinged()函数的使用的条件转移指令是 JBE 和 JAE,而 f_signed()函数使用的条件转移指令则是 JLE 和 JGE。<br>使用 GCC 编译上述程序,可得到 f_unsigned()的汇编指令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_a$=8   ;size=4</span><br><span class="line">_b$=12  ;size=4</span><br><span class="line">_f_unsifned PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp,esp</span><br><span class="line">	mov eax,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp eax,DWORD PTR _b$[ebp]</span><br><span class="line">	jbe SHORT $LN3@f _unsigned</span><br><span class="line">	push OFFSET $SG2761    &#x27;a&gt;b&#x27;</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line">$LN3@f _unsigned:</span><br><span class="line">	mov ecx,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp ecx,DWORD PTR _b$[ebp]</span><br><span class="line">	jne SHORT $LN2@f_unsigned</span><br><span class="line">	push OFFSET $SG2763  ; &#x27;a==b&#x27;</span><br><span class="line">	call _printf</span><br><span class="line">	add esp, 4</span><br><span class="line">$LN2@f_unsigned:</span><br><span class="line">	mov edx,DWORD PTR _a$[ebp]</span><br><span class="line">	cmp edx,DWORD PTR _b$[ebp]</span><br><span class="line">	jae SHORT $LN4@f_unsigned</span><br><span class="line">	push OFFSET $SG2765   ; &#x27;a&lt;b&#x27;</span><br><span class="line">	call _printf</span><br><span class="line">	add esp, 4</span><br><span class="line">LN4@f_unsigned:</span><br><span class="line">	pop ebp</span><br><span class="line">	Ret 0</span><br><span class="line">_f_unsigned ENDP</span><br></pre></td></tr></table></figure>
<p>GCC 编译的结果与 MSVC 编译的结果基本相同。<br>经 GCC 编译后,f_unsigned()函数使用的条件转移指令是 JBE(Jump if Below or Equal,相当于 JLE)和 JAE(Jump if Above or Equal,相当于 JGE)。JA&#x2F;JAE&#x2F;JB&#x2F;JBE 与 JG&#x2F;JGE&#x2F;JL&#x2F;JLE 的区别,在于它们检查的标志位不同:前者检查借&#x2F;进位标志位 CF(1 意味着小于)和零标志位 ZF(1 意味着相等),后者检查“SF<br>XOR OF”(1 意味着异号)和 ZF。从指令参数的角度看,前者适用于 unsigned (无符号)类型数据的(CMP)运算,而后者的适用于 signed(有符号)类型数据的运算。可见,根据条件转移的指令,我们可以直接判断 CMP 所比较的变量的数据类型。</p>
<p>接下来,我们一起研究 main()函数的汇编代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_main PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp,esp</span><br><span class="line">	push 2</span><br><span class="line">	push 1</span><br><span class="line">	call _f_signed</span><br><span class="line">	add esp,8</span><br><span class="line">	push 2</span><br><span class="line">	push 1</span><br><span class="line">	call _f_unsigned</span><br><span class="line">	add esp,8</span><br><span class="line">	xor eax,eax</span><br><span class="line">	pop ebp</span><br><span class="line">	ret 0</span><br><span class="line">_main ENDP</span><br></pre></td></tr></table></figure>
<h4 id="x86-MSVC-OllDbg"><a href="#x86-MSVC-OllDbg" class="headerlink" title="x86+MSVC+OllDbg"></a>x86+MSVC+OllDbg</h4><p>我们可以通过 OllyDbg 直观地观察到指令对标志寄存器的影响。我们先用 OllyDbg 观察 f_unsigned()函数比较无符号数的过程。f_unsigned()函数使用了 CMP 指令,分三次比较了两个相同的 unsigned 类型数据。因为参数相同,所以 CMP 设置的标志位必定相同。<br>如下图 所示,在运行到第一个条件转移指令时,C&#x3D;1, P&#x3D;1, A&#x3D;1, Z&#x3D;0, S&#x3D;1, T&#x3D;0, D&#x3D;0, O&#x3D;0。OllyDbg会使用标志位的首字母作为该标志位的简称.<br>OllyDbg 在左下窗口进行提示,JBE 条件跳转指令的条件已经达成,下一步会进行相应跳转。这种预测准确无误,JBE 的触发条件是(CF&#x3D;1 或 ZF&#x3D;1)。条件表达式为真时,JBE 确实会进行跳转。<br><img src="/images/580ed4d7a27514ace73ff4494450f5940e6cebc3.png" alt="01.png"><br>如下图所示,在运行到第二个条件转移指令——JNZ 指令时,ZF&#x3D;0。所以 OllyDbg 能够判断程序会进行相应跳转<br><img src="/images/b34259296524fba6ee3624fcdd6cf7f9d7bd1673.png" alt="02.png"><br>如下图所示,运行到第三个条件转移指令——JNB 指令的时候,借&#x2F;进位标志 CF&#x3D;0,条件表达式会为假,所以不会发生跳转,程序将执行第三个 printf()指令。<br><img src="/images/0e25f1f9c88bd3dd66293bae9952cec7a6a5dfc5.png" alt="03.png"></p>
<p>现在来调试下示例程序里的 f_signed()函数,它的参数为 signed 型数据。<br>在运行 f_signed()函数时,标志位的状态和刚才一样。即,运行 CMP 指令之后, C&#x3D;1, P&#x3D;1, A&#x3D;1, Z&#x3D;0, S&#x3D;1,T&#x3D;0, D&#x3D;0, O&#x3D;0。<br>第一个条件转移指令——JLE 指令将会被触发,如下图所示：<br><img src="/images/e7c2977fad694173c565d5865660ebd8565a737e.png" alt="11.png"><br>触发 JLE 的条件是 ZF&#x3D;1 或 SF≠OF。本例满足 SF≠OF 的条件。由于 ZF&#x3D;0,第二个条件转移指令——JNZ 指令会被触发,如下图所示：<br><img src="/images/48b2cada6dba2552b832c767976c8d651d7da4ea.png" alt="12.png"><br>而第三个条件转移指令——JGE 指令不会被触发。触发 JGE 的条件是 SF&#x3D;OF,而当前情形不满足这个条件,如下图所示：<br><img src="/images/c6eef2fc870cd95ed7191320b0c8f2761c4580cf.png" alt="13.png"></p>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><h4 id="Non-optimizing-GCC"><a href="#Non-optimizing-GCC" class="headerlink" title="Non-optimizing GCC"></a>Non-optimizing GCC</h4><p>如果关闭了GCC的优化选项,那么它编译出来的程序和MSVC编译出来的程序没什么区别,只不过就是把printf()函数替换为了puts()函数。</p>
<h4 id="Optimizing-GCC"><a href="#Optimizing-GCC" class="headerlink" title="Optimizing GCC"></a>Optimizing GCC</h4><p>既然 CMP 比较的是相同的值,比较之后的标志位的状态也相同,那么何必要对同样的参数进行多次比较呢?或许 MSVC 真的不能再智能一些了;但是启用优化选项后,GCC 4.8.1 确实能够进行这种深度优化<br>指令清单  GCC 4.8.1 f_signed()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">f_signed:</span><br><span class="line">	mov eax, DWORD PTR [esp+8]</span><br><span class="line">	cmp DWORD PTR [esp+4], eax</span><br><span class="line">	jg .L6</span><br><span class="line">	je .L7</span><br><span class="line">	jge .L1</span><br><span class="line">	mov DWORD PTR [esp+4], OFFSET FLAT:.LC2 ; &quot;a&lt;b&quot;</span><br><span class="line">	jmp puts</span><br><span class="line">.L6:</span><br><span class="line">	mov DWORD PTR [esp+4], OFFSET FLAT:.LC0 ; &quot;a&gt;b&quot;</span><br><span class="line">	jmp puts</span><br><span class="line">.L1</span><br><span class="line">	ret ret</span><br><span class="line">.L7</span><br><span class="line">	mov DWORD PTR [esp+4], OFFSET FLAT:.LC1 ; &quot;a==b&quot;</span><br><span class="line">	jmp puts</span><br></pre></td></tr></table></figure>
<p>很明显,它使用 jmp 指令替代了臃肿的“CALL ……puts …… RETN”指令。<br>在 x86 的系统中,这种程序比较少见。MSVC 2012 做不到 GCC 那种程度的深度优化。<br>另一方面,汇编语言的编程人员确实可能学会 Jcc 指令的连用技巧。所以,如果您遇到了这样精简的程序,而且还能够判断出它不是 GCC 编译出来的程序,那么您基本上可以判断它是手写出来的汇编程序。<br>即使开启了同样的优化选项,f_unsigned()函数对应的指令也没有那么精致:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">f_unsigned:</span><br><span class="line">	push esi</span><br><span class="line">	push ebx</span><br><span class="line">	sub esp,20</span><br><span class="line">	mov esi,DWORD PTR [esp+32]</span><br><span class="line">	mov ebx,DWORD PTR [esp+64]</span><br><span class="line">	cmp esi,ebx</span><br><span class="line">	ja .L13</span><br><span class="line">	cmp esi,ebx    ; instruction may be removed</span><br><span class="line">	je .L14</span><br><span class="line">.L10:</span><br><span class="line">	jb .L15</span><br><span class="line">	add esp, 20</span><br><span class="line">	pop ebx</span><br><span class="line">	pop esi</span><br><span class="line">	ret</span><br><span class="line">.L15:</span><br><span class="line">	mov DWORD PTR [esp+32], OFFSET FLAT:.LC2 ; &quot;a&lt;b&quot;</span><br><span class="line">	add esp, 20</span><br><span class="line">	pop ebx</span><br><span class="line">	pop esi</span><br><span class="line">	jmp puts</span><br><span class="line">.L13:</span><br><span class="line">	mov DWORD PTR [esp], OFFSET FLAT:.LC0 ; &quot;a&gt;b&quot;</span><br><span class="line">	call puts</span><br><span class="line">	cmp esi, ebx</span><br><span class="line">	jne .L10</span><br><span class="line">.L14:</span><br><span class="line">	mov DWORD PTR [esp+32], OFFSET FLAT:.LC1 ; &quot;a==b&quot;</span><br><span class="line">	add esp, 20</span><br><span class="line">	pop ebx</span><br><span class="line">	pop esi</span><br><span class="line">	jmp puts</span><br></pre></td></tr></table></figure>
<p>程序中只有两条 CMP 指令,至少它优化去了一个 CMP 指令。可见,GCC 4.8.1 的优化算法还有改进的空间.</p>
<h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>32 位 ARM 程序</p>
<h4 id="Optimizing-Keil-6-x2F-2013-ARM-mode"><a href="#Optimizing-Keil-6-x2F-2013-ARM-mode" class="headerlink" title="Optimizing Keil 6&#x2F;2013 (ARM mode)"></a>Optimizing Keil 6&#x2F;2013 (ARM mode)</h4><p>指令清单 Optimizing Keil 6&#x2F;2013 (ARM mode)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:000000B8				EXPORT f_signed</span><br><span class="line">.text:000000B8		f_signed 		; CODE XREF: main+C</span><br><span class="line">.text:000000B8 70 40 2D E9	STMFD SP!, &#123;R4-R6,LR&#125;</span><br><span class="line">.text:000000BC 01 40 A0 E1	MOV R4, R1</span><br><span class="line">.text:000000C0 04 00 50 E1	CMP R0, R4</span><br><span class="line">.text:000000C4 00 50 A0 E1	MOV R5, R0</span><br><span class="line">.text:000000C8 1A 0E 8F C2	ADRGT R0, aAB     ; &quot;a&gt;b\n&quot;</span><br><span class="line">.text:000000CC A1 18 00 CB	BLGT __2printf</span><br><span class="line">.text:000000D0 04 00 55 E1	CMP R5, R4</span><br><span class="line">.text:000000D4 67 0F 8F 02	ADREQ R0, aAB_0; &quot;a==b\n&quot;</span><br><span class="line">.text:000000D8 9E 18 00 0B	BLEQ __2printf</span><br><span class="line">.text:000000DC 04 00 55 E1	CMP R5,R4</span><br><span class="line">.text:000000E0 70 80 BD A8	LDMGEFD SP!, &#123;R4-R6,PC&#125;</span><br><span class="line">.text:000000E4 70 40 BD E8	LDMFD SP!, &#123;R4-R6,LR&#125;</span><br><span class="line">.text:000000E8 19 0E 8F E2	ADR R0, aAB_1 ; &quot;a&lt;b\n&quot;</span><br><span class="line">.text:000000EC 99 18 00 EA	B __2printf</span><br><span class="line">.text:000000EC ; End of function f_signed</span><br></pre></td></tr></table></figure>
<p>RM 模式的多数指令都存在着相应的条件执行指令。这些派生出来的条件执行指令仅会在特定标志位为 1的情况下执行。换句话说,只有当前面存在比较数值的指令时,后面才可能会出现这种派生出来的条件执行指令。<br>举例来讲,加法指令 ADD 指令实际上是 ADDAL 指令。“AL”就是 always 的缩写,即 ADDAL 总会被无条件执行。在 32 位的 ARM 指令中,条件判断表达式被封装在条件执行指令的前(最高) 4 位——条件字段(conditionfield)里。即使是无条件转移指令 B 指令,其前 4 位还是条件字段。从指令构成上说,B 指令仍然属于条件转移指令,只不过它的条件字段是 AL 而已。顾名思义,AL 的作用就是忽略标志寄存器、永远执行这条指令。<br>ADRGT 指令中的 GT 代表 greater than(大于)。该指令依据先前 CMP 指令的比较结果,而判断是否执行寻址指令。当且仅当 CMP 比较的第一个值大于第二个值的时候,ADRGT 指令才会执行寻址(ADR)指令。<br>后面的 BLGT 指令有异曲同工之妙。仅在相同条件下,即当且仅当 CMP 比较的第一个值大于第二个值的时候,BLGT 指令才会执行 BL 指令。在这个条件成立的时候,前面的 ADRGT 指令已经把字符串“a&gt;b &#x2F;n”的地址赋值给 R0 寄存器,成为了 printf()的参数,而 BLGT 负责调用 printf()。可见,当且仅当在 R0 的值(变量 a)大于R4 的值(变量 b)的情况下,计算机才会运行后面那组带有-GT 后缀的指令。很显然,这是一组相互关联的指令。<br>后面的 ADREQ 和 BLEQ 指令,都在最近一个 CMP 的操作数相等的情况下才会讲行 ADR 和 BL 指令的操作。程序之中连续两次出现“CMP R5, R4”指令,这是因为夹在其间的 printf()函数可能会影响标志位。<br>LDMGEFD 是“Great or Equal (大于或等于)”的情况下进行 LDMFD (Load Multiple Full Descending) 操作的指令。依此类推,“LDMGEFD SP!, {R4-R6,PC}”指令起到函数尾声的作用,不过它只会在“a&gt;&#x3D;b”的时候才会结束本函数。<br>如果上述条件不成立,即“a&lt;b”的时候,会执行下一条指令“LDMFD SP!, {R4-R6,LR}”。这同样起到函数尾声的作用。该指令将恢复 R4~R6 寄存器、LR 寄存器的值,而不恢复 PC 寄存器的值,且不会退出当前函数。<br>函数最后的两条指令,分别向 printf()函数传递参数(字符串“a&lt;b\n”),并且调用 printf()函数。当调用方函数调用(跳转到)printf()函数之后,调用方函数可以伴随 printf()函数<br>退出而退出。<br>f_unsigned()函数与 f_signed()函数的功能十分类似。不同之处是它用到了 ADRHI、BLHI 和 LDMSFD指令。指令尾部的-HI 代表 Unsigned Higher,CS 代表 Carry Set (greater than or equal)。因为参数的数据类型有所变化,所以这两个函数的具体指令有所区别。<br>这个程序的 main()函数的汇编指令如下<br>指令清单 main()函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:00000128			EXPORT main</span><br><span class="line">.text:00000128		main</span><br><span class="line">.text:00000128 10 40 2D E9	STMFD SP!, &#123;R4,LR&#125;</span><br><span class="line">.text:0000012C 02 10 A0 E3	MOV R1, #2</span><br><span class="line">.text:00000130 01 00 A0 E3	MOV R0, #1</span><br><span class="line">.text:00000134 DF FF FF EB	BL f_signed</span><br><span class="line">.text:00000138 02 10 A0 E3	MOV R1, #2</span><br><span class="line">.text:0000013C 01 00 A0 E3	MOV R0, #1</span><br><span class="line">.text:00000140 EA FF FF EB	BL f_unsigned</span><br><span class="line">.text:00000144 00 00 A0 E3	MOV R0, #0</span><br><span class="line">.text:00000148 10 80 BD EB	LDMFD SP!, &#123;R4,PC&#125;</span><br><span class="line">.text:00000148		; End of function main</span><br></pre></td></tr></table></figure>

<p>可见,ARM 模式的程序可以完全不依赖条件转移指令。<br>这样做有什么优点呢?依赖精简指令集(RISC)的ARM处理器采用流水线技术(pipeline)<br>。简单地说,这种处理器在跳转指令方面的性能不怎么优越,所以它们的分支预测处理器(branch predictor unites)决定了整体的性能。对于采用流水线技术的处理器来说,运行其上的程序跳转次数越少(无论是条件转移还是无条件转移),程序的性能就越高。条件执行指令 ,会受益于其跳跃次数最少的优点,体现出最高的效率。<br>x86 指令集里只有 CMOVcc 指令,没有其他的条件执行指令了。CMOVcc 指令是仅在特定标志位为 1(通常由 CMP 指令设置)的情况下才会执行 MOV 操作的条件执行指令。</p>
<h2 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int my_abs (int i)</span><br><span class="line">&#123;</span><br><span class="line">	if (i&lt;0)</span><br><span class="line">		return -i;</span><br><span class="line">	else</span><br><span class="line">		return i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Optimizing-MSVC"><a href="#Optimizing-MSVC" class="headerlink" title="Optimizing MSVC"></a>Optimizing MSVC</h3><p>指令清单 Optimizing MSVC 2012 x64</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i$ = 8</span><br><span class="line">my_abs PROC</span><br><span class="line">; ECX = input</span><br><span class="line">	test   ecx, ecx</span><br><span class="line">; check for sign of input value</span><br><span class="line">; skip NEG instruction if sign is positive</span><br><span class="line">	jns SHORT $LN2@my_abs</span><br><span class="line">; negate value</span><br><span class="line">	neg ecx</span><br><span class="line">$LN2@my_abs:</span><br><span class="line">; prepare result in EAX:</span><br><span class="line">	mov eax,ecx</span><br><span class="line">	ret 0</span><br><span class="line">my_abs ENDP</span><br></pre></td></tr></table></figure>
<p>GCC 4.9 的编译结果几乎相同。</p>
<h3 id="Optimizing-Keil-6-x2F-2013-Thumb-mode"><a href="#Optimizing-Keil-6-x2F-2013-Thumb-mode" class="headerlink" title="Optimizing Keil 6&#x2F;2013: Thumb mode"></a>Optimizing Keil 6&#x2F;2013: Thumb mode</h3><p>指令清单  Optimizing Keil 6&#x2F;2013:Thumb mode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_abs PROC</span><br><span class="line">	CMP r0,#0</span><br><span class="line">; is input value equal to zero or greater than zero?</span><br><span class="line">; skip RSBS instruction then</span><br><span class="line">	BGE |L0.6|</span><br><span class="line">; subtract input value from 0:</span><br><span class="line">	RSBS r0,r0,#0</span><br><span class="line">|L0.6|</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>
<p>ARM 平台没有负数运算指令,所以 Keil 编译器使用了“零减去数值”的减法运算指令“Reverse Subtract”(减数和被减数位置对调的减法运算),同样达到了替换符号的效果。</p>
<h3 id="Optimizing-Keil-6-x2F-2013-ARM-mode-1"><a href="#Optimizing-Keil-6-x2F-2013-ARM-mode-1" class="headerlink" title="Optimizing Keil 6&#x2F;2013: ARM mode"></a>Optimizing Keil 6&#x2F;2013: ARM mode</h3><p>因为 ARM 模式的指令集存在条件执行指令,所以开启优化选项后可得到如下指令。<br>指令清单  Optimizing Keil 6&#x2F;2013:ARM mode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_abs PROC</span><br><span class="line">	CMP</span><br><span class="line">r0,#0</span><br><span class="line">; execute &quot;Reverse Subtract&quot; instruction only if input value is less than 0:</span><br><span class="line">	RSBLT r0,r0,#0</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>
<p>即使没有使用条件转移指令它也实现相同的功能</p>
<h3 id="Non-optimizng-GCC-4-9-ARM64"><a href="#Non-optimizng-GCC-4-9-ARM64" class="headerlink" title="Non-optimizng GCC 4.9 (ARM64)"></a>Non-optimizng GCC 4.9 (ARM64)</h3><p>ARM64 的指令集存在求负运算的 NEG 指令。<br>指令清单  Optimizing GCC 4.9 (ARM64)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my_abs:</span><br><span class="line">	subs p, sp, #16</span><br><span class="line">	str w0, [sp,12]</span><br><span class="line">	ldr w0, [sp,12]</span><br><span class="line">; compare input value with contents of WZR register</span><br><span class="line">; (which always holds zero)</span><br><span class="line">	cmp w0, wzr</span><br><span class="line">	bge .L2</span><br><span class="line">	ldr w0, [sp,12]</span><br><span class="line">	neg w0, w0</span><br><span class="line">	b .L3</span><br><span class="line">.L2:</span><br><span class="line">	ldr w0, [sp,12]</span><br><span class="line">.L3:</span><br><span class="line">	add sp, sp, 16</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p>指令清单 Optimizing GCC 4.4.5 (IDA)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_abs:</span><br><span class="line">; jump if $a0&lt;0:</span><br><span class="line">	bltz $a0, locret_10</span><br><span class="line">; just return input value ($a0) in $v0:</span><br><span class="line">	move $v0, $a0</span><br><span class="line">	jr $ra</span><br><span class="line">	or $at, $zero ; branch delay slot, NOP</span><br><span class="line">locret_10:</span><br><span class="line">; negate input value and store it in $v0:</span><br><span class="line">	jr $ra</span><br><span class="line">; this is pseudoinstruction. in fact, this is &quot;subu $v0,$zero,$a0&quot; ($v0=0-$a0)</span><br><span class="line">	negu $v0, $a0</span><br></pre></td></tr></table></figure>
<p>这里出现了新指令 BLTZ(Branch if Less Than Zero),以及伪指令 NEGU。NEGU 指令计算零减去操作数的差。SUBU 和 NEGU 指令中的后缀 U 代表它的操作数是无符号型数据,并且在整数溢出的情况下不会触发异常处理机制。</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> const char* f (int a)</span><br><span class="line">&#123;</span><br><span class="line">	return a==10 ? &quot;it is ten&quot; : &quot;it is not ten&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a>x86</h3><p>在编译含有条件运算符的语句时,早期无优化功能的编译器会以编译“if&#x2F;else”语句的方法进行处理。<br>指令清单 Non-optimizing MSVC 2008</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$SG746 DB &#x27;it is ten&#x27;, 00H</span><br><span class="line">$SG747 DB &#x27;it is not ten&#x27;, 00H</span><br><span class="line"></span><br><span class="line">tv65 = -4 ; this will be used as a temporary variable</span><br><span class="line">_a$ = 8</span><br><span class="line">_f	PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	push ecx</span><br><span class="line">; compare input value with 10</span><br><span class="line">	cmp DWORD PTR _a$[ebp], 10</span><br><span class="line">; jump to $LN3@f if not equal</span><br><span class="line">	jne SHORT $LN3@f</span><br><span class="line">; store pointer to the string into temporary variable:</span><br><span class="line">	mov DWORD PTR tv65[ebp], OFFSET $SG746 ; &#x27;it is ten&#x27;</span><br><span class="line">; jump to exit</span><br><span class="line">	jmp SHORT $LN4@f</span><br><span class="line">$LN3@f:</span><br><span class="line">; store pointer to the string into temporary variable:</span><br><span class="line">	mov DWORD PTR tv65[ebp], OFFSET $SG747 ; &#x27;it is not ten&#x27;</span><br><span class="line">$LN4@f:</span><br><span class="line">; this is exit. copy pointer to the string from temporary variable to EAX.</span><br><span class="line">	mov eax, DWORD PTR tv65[ebp]</span><br><span class="line">	mov esp, ebp</span><br><span class="line">	pop ebp</span><br><span class="line">	ret 0</span><br><span class="line">_f	ENDP Optimizing MSVC 2008</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指令清单  Optimizing MSVC 2008</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$SG792 DB &#x27;it is ten&#x27;, 00H</span><br><span class="line">$SG792 DB &#x27;it is not ten&#x27;, 00H</span><br><span class="line">_a$ = 8 ; size = 4</span><br><span class="line">_f	PROC</span><br><span class="line">; compare input value with 10</span><br><span class="line">	cmp DWORD PTR _a$[esp-4], 10</span><br><span class="line">	mov eax, OFFSET $SG792 ; &#x27;it is ten&#x27;</span><br><span class="line">; jump to $LN4@f if equal</span><br><span class="line">	je SHORT $LN4@f</span><br><span class="line">	mov eax, OFFSET $SG793 ; &#x27;it is not ten&#x27;</span><br><span class="line">$LN4@f:</span><br><span class="line">	ret 0</span><br><span class="line">_f	ENDP</span><br></pre></td></tr></table></figure>
<p>新编译器生成的程序更为简洁。<br>指令清单 Optimizing MSVC 2012 x64</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$SG1355 DB		&#x27;it is ten&#x27;, 00H</span><br><span class="line">$SG1356 DB		&#x27;it is not ten&#x27;, 00H</span><br><span class="line"></span><br><span class="line">a$	= 8</span><br><span class="line">f	PROC</span><br><span class="line">; load pointers to the both strings</span><br><span class="line">	lea rdx, OFFSET FLAT:$SG1355 ; &#x27;it is ten&#x27;</span><br><span class="line">	lea rax, OFFSET FLAT:$SG1356 ; &#x27;it is not ten&#x27;</span><br><span class="line">; compare input value with 10</span><br><span class="line">	cmp ecx, 10</span><br><span class="line">; if equal, copy value from RDX (&quot;it is ten&quot;)</span><br><span class="line">; if not, do nothing. pointer to the string &quot;it is not ten&quot; is still in RAX as for now.</span><br><span class="line">	cmove rax, rdx</span><br><span class="line">	ret 0</span><br><span class="line">f	ENDP</span><br></pre></td></tr></table></figure>
<p>启用优化选项后,GCC 4.8 生成的 x86 指令同样使用了 CMOVcc 指令。相比之下,在关闭优化功能的情况下,GCC 4.8 用条件转移指令编译条件操作符。</p>
<h3 id="ARM-1"><a href="#ARM-1" class="headerlink" title="ARM"></a>ARM</h3><p>启用优化功能之后,Keil 生成的 ARM 代码会应用条件运行指令 ADRcc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f PROC</span><br><span class="line">; compare input value with 10</span><br><span class="line">	CMP r0, #0xa</span><br><span class="line">; if comparison result is EQual, copy pointer to the &quot;it is ten&quot; string into R0</span><br><span class="line">	ADREQ r0,|L0.16| ; &quot;it is ten&quot;</span><br><span class="line">; if comparison result is Not Equal, copy pointer to the &quot;it is not ten&quot; string into R0</span><br><span class="line">	ADRNE r0,|L0.28| ; &quot;it is not ten&quot;</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br><span class="line">|L0.16|</span><br><span class="line">	DCB &quot;it is ten&quot;,0</span><br><span class="line">|L0.28|</span><br><span class="line">	DCB &quot;it is not ten&quot;,0</span><br></pre></td></tr></table></figure>
<p>除非存在人为干预,否则 ADREQ 和 ADRNE 指令不可能在同一次调用期间都被执行。<br>在启用优化功能之后,Keil 会给编译出的 Thumb 模式代码分配条件转移指令。毕竟在 Thumb 模式的指令之中,没有支持标志位判断的赋值指令。<br>指令清单  Optimizing Keil 6&#x2F;2013 (Thumb mode)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f PROC</span><br><span class="line">; compare input value with 10</span><br><span class="line">	CMP r0,#0xa</span><br><span class="line">; jump to |L0.8| if EQual</span><br><span class="line">	BEQ |L0.8|</span><br><span class="line">	ADR r0,|L0.12| ; &quot;it is not ten&quot;</span><br><span class="line">	BX lr</span><br><span class="line">|L0.8|</span><br><span class="line">	ADR r0,|L0.28| ; &quot;it is ten&quot;</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br><span class="line">|L0.12|</span><br><span class="line">	DCB &quot;it is not ten&quot;,0</span><br><span class="line">|L0.28|</span><br><span class="line">	DCB &quot;it is ten&quot;,0</span><br></pre></td></tr></table></figure>
<h3 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a>ARM64</h3><p>启用优化功能之后,GCC(Linaro)4.9 编译出来的 ARM64 程序同样用条件转移指令实现条件运算符。<br>指令清单  Optimizing GCC (Linaro) 4.9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f:</span><br><span class="line">	cmp x0, 10</span><br><span class="line">	beq .L3     ; branch if equal</span><br><span class="line">	adrp x0, .LC1 ; &quot;it is ten&quot;</span><br><span class="line">	add x0, x0, :lo12:.LC1</span><br><span class="line">	ret </span><br><span class="line">.L3:</span><br><span class="line">	adrp ret x0, .LC0 ; &quot;it is not ten&quot;</span><br><span class="line">	add x0, x0, :lo12:.LC0</span><br><span class="line">.LC0:</span><br><span class="line">	.string &quot;it is ten&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string &quot;it is not ten&quot;</span><br></pre></td></tr></table></figure>
<p>ARM64 同样没有能够判断标志位的条件赋值指令。而 32 位的ARM指令集 1 ,以及x86 的CMOVcc指令都可以根据相应标志位进行条件赋值。虽然ARM64 存在“条件选择”指令CSEL(Conditional SELect),但是GCC 4.9 似乎无法给这种程序分配上这条指令。</p>
<h3 id="MIPS-1"><a href="#MIPS-1" class="headerlink" title="MIPS"></a>MIPS</h3><p>不幸的是,GCC 4.45 在编译 MIPS 程序方面的智能程度也有待完善。<br>指令清单  Optimizing GCC 4.4.5 (assembly output)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$LC0:</span><br><span class="line">	.ascii &quot;it is not ten\000&quot;</span><br><span class="line">$LC1:</span><br><span class="line">	.ascii &quot;it is ten\000&quot;</span><br><span class="line">f:</span><br><span class="line">	li $2,10     # 0xa</span><br><span class="line">; compare $a0 and 10, jump if equal:</span><br><span class="line">	beq $4,$2,$L2</span><br><span class="line">	nop ; branch delay slot</span><br><span class="line"></span><br><span class="line">; leave address  of &quot;it is not ten&quot; string in $v0 and return:</span><br><span class="line">	lui $2,%hi($LC0)</span><br><span class="line">	j $31</span><br><span class="line">	addiu $2,$2,%lo($LC0)</span><br><span class="line">$L2:</span><br><span class="line">; leave address of &quot;it is ten&quot; string in $v0 and return:</span><br><span class="line">	lui $2,%hi($LC1)</span><br><span class="line">	j $31</span><br><span class="line">	addiu $2,$2,%lo($LC1)</span><br></pre></td></tr></table></figure>
<h3 id="使用-if-x2F-else-替代条件运算符"><a href="#使用-if-x2F-else-替代条件运算符" class="headerlink" title="使用 if&#x2F;else 替代条件运算符"></a>使用 if&#x2F;else 替代条件运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const char* f (int a)</span><br><span class="line">&#123;</span><br><span class="line">if (a==10)</span><br><span class="line">return &quot;it is ten&quot;;</span><br><span class="line">else</span><br><span class="line">return &quot;it is not ten&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>启用优化功能之后,GCC 4.8 在编译 x86 程序时能够应用 CMOVcc 指令。<br>指令清单 Optimizing GCC 4.8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">	.string &quot;it is ten&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string &quot;it is not ten&quot;</span><br><span class="line">f:</span><br><span class="line">.LFB0:</span><br><span class="line">; compare input value with 10</span><br><span class="line">	cmp DWORD PTR [esp+4], 10</span><br><span class="line">	mov edx, OFFSET FLAT:.LC1 ; &quot;it is not ten&quot;</span><br><span class="line">	mov eax, OFFSET FLAT:.LC0 ; &quot;it is ten&quot;</span><br><span class="line">; if comparison result is Not Equal, copy EDX value to EAX</span><br><span class="line">; if not, do nothing</span><br><span class="line">	cmovne eax, edx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>启用优化功能之后,编译器会尽可能地避免使用条件转移指令。</p>
<h2 id="比较最大值和最小值"><a href="#比较最大值和最小值" class="headerlink" title="比较最大值和最小值"></a>比较最大值和最小值</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><h4 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int my_max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a&gt;b)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;;</span><br><span class="line">int my_min(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a&lt;b)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="指令清单-Non-optimizing-MSVC-2013"><a href="#指令清单-Non-optimizing-MSVC-2013" class="headerlink" title="指令清单 Non-optimizing MSVC 2013"></a>指令清单 Non-optimizing MSVC 2013</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_a$ = 8</span><br><span class="line">_b$ = 12</span><br><span class="line">_my_min PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	mov eax, DWORD PTR _a$[ebp]</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp eax, DWORD PTR _b$[ebp]</span><br><span class="line">; jump, if A is greater or equal to B:</span><br><span class="line">	jge SHORT $LN2@my_min</span><br><span class="line">; reload A to EAX if otherwise and jump to exit</span><br><span class="line">	mov eax, DWORD PTR _a$[ebp]</span><br><span class="line">	jmp SHORT $LN3@my_min</span><br><span class="line">	jmp SHORT $LN3@my_min ; this is redundant JMP</span><br><span class="line">$LN2@my_min:</span><br><span class="line">; return B</span><br><span class="line">	mov eax, DWORD PTR _b$[ebp]</span><br><span class="line">$LN3@my_min:</span><br><span class="line">	pop ebp</span><br><span class="line">	ret 0</span><br><span class="line">_my_min ENDP</span><br><span class="line">_a$ = 8</span><br><span class="line">_b$ = 12</span><br><span class="line">_my_max PROC</span><br><span class="line">	push ebp</span><br><span class="line">	mov ebp, esp</span><br><span class="line">	mov eax, DWORD PTR _a$[ebp]</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp eax, DWORD PTR _b$[ebp]</span><br><span class="line">; jump if A is less or equal to B:</span><br><span class="line">	jle SHORT $LN2@my_max</span><br><span class="line">; reload A to EAX if otherwise and jump to exit</span><br><span class="line">	mov eax, DWORD PTR _a$[ebp]</span><br><span class="line">	jmp SHORT $LN3@my_max</span><br><span class="line">	jmp SHORT $LN3@my_max ; this is redundant JMP</span><br><span class="line">$LN2@my_max:</span><br><span class="line">; return B</span><br><span class="line">	mov eax, DWORD PTR _b$[ebp]</span><br><span class="line">$LN3@my_max:</span><br><span class="line">	pop ebp</span><br><span class="line">	ret 0</span><br><span class="line">_my_max ENDP</span><br></pre></td></tr></table></figure>
<p>两个函数的唯一区别就是条件转移指令:第一个函数使用的是 JGE(Jump if Greater or Equal),而第二个函数使用的是 JLE(Jump if Less or Equal)。上述每个函数里都存在一个多余的 JMP 指令。这可能是 MSVC 的问题。</p>
<p>** 无分支指令的编译方法**<br>Keil 编译的 Thumb 模式程序与 x86 程序有几分相似</p>
<h4 id="指令清单-Optimizing-Keil-6-x2F-2013-Thumb-mode"><a href="#指令清单-Optimizing-Keil-6-x2F-2013-Thumb-mode" class="headerlink" title="指令清单   Optimizing Keil 6&#x2F;2013 (Thumb mode)"></a>指令清单   Optimizing Keil 6&#x2F;2013 (Thumb mode)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">my_max PROC</span><br><span class="line">; R0=A</span><br><span class="line">; R1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	CMP r0,r1</span><br><span class="line">; branch if A is greater then B:</span><br><span class="line">	BGT |L0.6|</span><br><span class="line">; otherwise (A&lt;=B) return R1 (B):</span><br><span class="line">	MOVS r0,r1</span><br><span class="line">|L0.6|</span><br><span class="line">; return</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br><span class="line">my_min PROC</span><br><span class="line">; R0=A</span><br><span class="line">; R1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	CMP r0,r1</span><br><span class="line">; branch if A is less then B:</span><br><span class="line">	BLT |L0.14|</span><br><span class="line">; otherwise (A&gt;=B) return R1 (B):</span><br><span class="line">	MOVS r0,r1</span><br><span class="line">|L0.14|</span><br><span class="line">; return</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>
<p>两个函数所用的转移指令不同:一个是 BGT,而另一个是 BLT。<br>在编译 ARM 模式程序时,编译器可能会使用条件执行指令(即“有分支”指令)<br>。这种程序会显得更为短小。在编译条件表达式时,Keil 编译器使用了 MOVcc 指令。</p>
<h4 id="指令清单-Optimizing-Keil-6-x2F-2013-ARM-mode"><a href="#指令清单-Optimizing-Keil-6-x2F-2013-ARM-mode" class="headerlink" title="指令清单  Optimizing Keil 6&#x2F;2013 (ARM mode)"></a>指令清单  Optimizing Keil 6&#x2F;2013 (ARM mode)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">my_max PROC</span><br><span class="line">; R0=A</span><br><span class="line">; R1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	CMP r0,r1</span><br><span class="line">; return B instead of A by placing B in R0</span><br><span class="line">; this instruction will trigger only if A&lt;=B (hence, LE - Less or Equal)</span><br><span class="line">; if instruction is not triggered (in case of A&gt;B), A is still in R0 register</span><br><span class="line">	MOVLE r0,r1</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br><span class="line">my_min PROC</span><br><span class="line">; R0=A</span><br><span class="line">; R1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	CMP r0,r1</span><br><span class="line">; return B instead of A by placing B in R0</span><br><span class="line">; this instruction will trigger only if A&gt;=B (hence, GE - Greater or Equal)</span><br><span class="line">; if instruction is not triggered (in case of A&lt;B), A value is still in R0 register</span><br><span class="line">	MOVGE r0,r1</span><br><span class="line">	BX lr</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>
<p>在启用优化功能的情况下,GCC 4.8.1 和 MSVC 2013 都能使用 CMOVcc 指令。这个指令相当于 ARM程序里的 MOVcc 指令。</p>
<h4 id="指令清单-Optimizing-MSVC-2013"><a href="#指令清单-Optimizing-MSVC-2013" class="headerlink" title="指令清单  Optimizing MSVC 2013"></a>指令清单  Optimizing MSVC 2013</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">my_max:</span><br><span class="line">	mov edx, DWORD PTR [esp+4]</span><br><span class="line">	mov eax, DWORD PTR [esp+8]</span><br><span class="line">; EDX=A</span><br><span class="line">; EAX=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp edx, eax</span><br><span class="line">; if A&gt;=B, load A value into EAX</span><br><span class="line">; the instruction idle if otherwise (if A&lt;B)</span><br><span class="line">	cmovge eax, edx</span><br><span class="line">	ret</span><br><span class="line">my_min:</span><br><span class="line">	mov edx, DWORD PTR [esp+4]</span><br><span class="line">	mov eax, DWORD PTR [esp+8]</span><br><span class="line">; EDX=A</span><br><span class="line">; EAX=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp edx, eax</span><br><span class="line">; if A&lt;=B, load A value into EAX</span><br><span class="line">; the instruction idle if otherwise (if A&gt;B)</span><br><span class="line">	cmovle eax, edx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h3 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h3><h4 id="程序-3"><a href="#程序-3" class="headerlink" title="程序"></a>程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">int64_t my_max(int64_t a, int64_t b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a&gt;b)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;;</span><br><span class="line">int64_t my_min(int64_t a, int64_t b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a&lt;b)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然编译出来的程序里存在不必要的数据交换,但是代码功能一目了然</p>
<h4 id="指令清单-Non-optimizing-GCC-4-9-1-ARM64"><a href="#指令清单-Non-optimizing-GCC-4-9-1-ARM64" class="headerlink" title="指令清单 Non-optimizing GCC 4.9.1 ARM64"></a>指令清单 Non-optimizing GCC 4.9.1 ARM64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">my_max:</span><br><span class="line">	sub sp,sp,#16</span><br><span class="line">	str x0,[sp,8]</span><br><span class="line">	str x1,[sp]</span><br><span class="line">	ldr x1,[sp,8]</span><br><span class="line">	ldr x0,[sp]</span><br><span class="line">	cmp X1,X0</span><br><span class="line">	ble .L2</span><br><span class="line">	ldr x0,[sp,8]</span><br><span class="line">	b .L3</span><br><span class="line">.L2:	</span><br><span class="line">	ldr x0,[sp]</span><br><span class="line">.L3:</span><br><span class="line">	add sp,sp,#16</span><br><span class="line">	ret</span><br><span class="line">my_min:</span><br><span class="line">	sub sp,sp,#16</span><br><span class="line">	str x0,[sp,8]</span><br><span class="line">	str x1,[sp]</span><br><span class="line">	ldr x1,[sp,8]</span><br><span class="line">	ldr x0,[sp]</span><br><span class="line">	cmp x1,x0</span><br><span class="line">	bge .L5</span><br><span class="line">	ldr x0,[sp]</span><br><span class="line">	b .L6</span><br><span class="line">.L5:</span><br><span class="line">	ldr x0,[sp]</span><br><span class="line">.L6:</span><br><span class="line">	add sp,sp,16</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>无分支指令的编译方法<br>既然函数参数就在寄存器里,那么就不必通过栈访问它们。</p>
<h4 id="指令清单-Optimizing-GCC-4-9-1-x64"><a href="#指令清单-Optimizing-GCC-4-9-1-x64" class="headerlink" title="指令清单   Optimizing GCC 4.9.1 x64"></a>指令清单   Optimizing GCC 4.9.1 x64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">my_max:</span><br><span class="line">; RDI=A</span><br><span class="line">; RSI=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp rdi, rsi</span><br><span class="line">; prepare B in RAX for return:</span><br><span class="line">	mov rax, rsi</span><br><span class="line">; if A&gt;=B, put A (RDI) in RAX for return.</span><br><span class="line">; this instruction is idle if otherwise (if A&lt;B)</span><br><span class="line">	cmovge rax, rdi</span><br><span class="line">	ret</span><br><span class="line">my_min:</span><br><span class="line">; RDI=A</span><br><span class="line">; RSI=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp rdi, rsi</span><br><span class="line">; prepare B in RAX for return:</span><br><span class="line">	mov rax, rsi</span><br><span class="line">; if A&lt;=B, put A (RDI) in RAX for return.</span><br><span class="line">; this instruction is idle if otherwise (if A&gt;B)</span><br><span class="line">	cmovle rax, rdi</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>MSVC 2013 的编译方法几乎一样。ARM64 指令集里有 CSEL 指令。它相当于 ARM 指令集中的 MOVcc 指令,以及 x86 平台的 CMOVcc指令。它只是名字不同:“Conditional SELect”。</p>
<h4 id="指令清单-Optimizing-GCC-4-9-1-ARM64"><a href="#指令清单-Optimizing-GCC-4-9-1-ARM64" class="headerlink" title="指令清单  Optimizing GCC 4.9.1 ARM64"></a>指令清单  Optimizing GCC 4.9.1 ARM64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">my_max:</span><br><span class="line">; X0=A</span><br><span class="line">; X1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp x0, x1</span><br><span class="line">; select X0 (A) to X0 if X0&gt;=X1 or A&gt;=B (Greater or Equal)</span><br><span class="line">; select X1 (B) to X0 if A&lt;B</span><br><span class="line">	csel x0, x0, x1, ge</span><br><span class="line">	ret</span><br><span class="line">my_min:</span><br><span class="line">; X0=A</span><br><span class="line">; X1=B</span><br><span class="line">; compare A and B:</span><br><span class="line">	cmp x0, x1</span><br><span class="line">; select X0 (A)  to X0 if X0&lt;=X1 or A&lt;=B (Less or Equal)</span><br><span class="line">; select X1 (B) to X0 if A&gt;B</span><br><span class="line">	csel x0, x0, x1, le</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h3 id="MIPS-2"><a href="#MIPS-2" class="headerlink" title="MIPS"></a>MIPS</h3><p>不幸的是,GCC 4.4.5 在编译 MIPS 程序方面的智能化程度有限。<br>指令清单 12.33 Optimizing GCC 4.4.5 (IDA)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">my_max:</span><br><span class="line">; set $v1 $a1&lt;$a0,or clear otherwise (if $01&gt;$a0):</span><br><span class="line">	slt $v1, $a1, $a0</span><br><span class="line">; jump, if $v1 iso (or $a1&gt;$a9):</span><br><span class="line">	beqz $v1, locret_10</span><br><span class="line">; this is branch delay slot</span><br><span class="line">; prepare $a1 in $v0 in case of branch triggered:</span><br><span class="line">	move $v0, $a1</span><br><span class="line">; no branch triggered, prepare $a0 in $v0:</span><br><span class="line">	move $v0, $a0</span><br><span class="line">locret_10:</span><br><span class="line">	jr $ra</span><br><span class="line">	or $at, $zero ; branch delay slot, NOP</span><br><span class="line">; the min() function is same, but input operands in SLT instruction are swapped:</span><br><span class="line">my_min</span><br><span class="line">	slt $v1, $a0, $a1</span><br><span class="line">	beqz $v1, locret_28</span><br><span class="line">	move $v0, $a1</span><br><span class="line">	move $v0, $a0</span><br><span class="line">locret_28:</span><br><span class="line">	jr $ra</span><br><span class="line">	or $at, $zero ; branch delay slot, NOP</span><br></pre></td></tr></table></figure>
<p>请注意分支延时槽现象:第一个 MOVE 指令“先于”BEQZ 指令运行,而第二个 MOVE 指令仅在不发生跳转的情况下才会被执行。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p> 条件转移指令的构造大体如下。</p>
<h3 id="x86-2"><a href="#x86-2" class="headerlink" title="x86"></a>x86</h3><p>指令清单  x86</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMP register, register/value</span><br><span class="line">Jcc true ; cc=condition code</span><br><span class="line">false:</span><br><span class="line">... some code to be executed if comparison result is false ...</span><br><span class="line">JMP exit</span><br><span class="line">true:</span><br><span class="line">... some code to be executed if comparison result is true ...</span><br><span class="line">exit:</span><br></pre></td></tr></table></figure>
<h3 id="ARM-2"><a href="#ARM-2" class="headerlink" title="ARM"></a>ARM</h3><p>指令清单 ARM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMP register, register/value</span><br><span class="line">Bcc true ; cc=condition code</span><br><span class="line">false:</span><br><span class="line">... some code to be executed if comparison result is false ...</span><br><span class="line">JMP exit</span><br><span class="line">true:</span><br><span class="line">... some code to be executed if comparison result is true ...</span><br><span class="line">exit:</span><br></pre></td></tr></table></figure>
<h3 id="MIPS-3"><a href="#MIPS-3" class="headerlink" title="MIPS"></a>MIPS</h3><p>指令清单  遇零跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEQZ REG, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>指令清单 遇负数跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BLTZ REG, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>指令清单 值相等的情况下跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEQ REG1, REG2, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>指令清单  值不等的情况下跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BNE REG1, REG2, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>指令清单  第一个值小于第二个值的情况下跳转(signed)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLT REG1, REG2, REG3</span><br><span class="line">BEQ REG1, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>指令清单  第一个值小于第二个值的情况下跳转(unsigned)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLTU REG1, REG2, REG3</span><br><span class="line">BEQ REG1, label</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="无分支指令-非条件指令"><a href="#无分支指令-非条件指令" class="headerlink" title="无分支指令(非条件指令)"></a>无分支指令(非条件指令)</h3><p>如果条件语句十分短,那么编译器可能会分配条件执行指令:</p>
<ol>
<li>编译 ARM 模式的程序时应用 MOVcc 指令。</li>
<li>编译 ARM64 程序时应用 CSEL 指令。</li>
<li>编译 x86 程序时应用 CMOVcc 指令。</li>
</ol>
<p>####ARM<br>在编译 ARM 模式的程序时,编译器可能用条件执行指令替代条件转移指令。<br>指令清单 ARM (ARM mode)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMP register, register/value</span><br><span class="line">instr1_cc ; some instruction will be executed if condition code is true</span><br><span class="line">instr2_cc ; some other instruction will be executed if other condition code is true</span><br><span class="line">... etc ...</span><br></pre></td></tr></table></figure>
<p>在被执行指令不修改任何标志位的情况下,程序可有任意多条的条件执行指令。<br>Thumb 模式的指令集里有 IT 指令。它可以把后续四条指令构成一个指令组,并且在条件表达式为真的时候运行这组指令。</p>
<p>指令清单 ARM (Thumb mode)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMP register, register/value</span><br><span class="line">ITEEE EQ ; set these suffixes: if-then-else-else-else</span><br><span class="line">instr1	;instraction will be executed if condition is true</span><br><span class="line">instr2	;instraction will be executed if condition is false</span><br><span class="line">instr3	;instraction will be executed if condition is false</span><br><span class="line">instr4	;instraction will be executed if condition is false</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94switch().html" rel="prev" title="逆向工程——switch()">
                  <i class="fa fa-chevron-left"></i> 逆向工程——switch()
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/re/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E2%80%94%E2%80%94scanf().html" rel="next" title="逆向工程——scanf()">
                  逆向工程——scanf() <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">m0nst3r</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
